FTM_0_CH_0_CH_1_ISR ()
{
  uint8 channelIndex;
  uint8 moduleIndex;

  <bb 2> :
  # DEBUG BEGIN_STMT
  moduleIndex = 0;
  # DEBUG BEGIN_STMT
  channelIndex = 0;
  # DEBUG BEGIN_STMT
  _1 = (int) moduleIndex;
  _2 = Ftm_Ocu_Ip_gapcxBase[_1];
  _3 = Ftm_Ocu_Ip_GetChannelEventStatus (_2, channelIndex);
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  Ftm_Ocu_Ip_Irq_ProcessChannelInterrupt (moduleIndex, channelIndex);

  <bb 4> :
  # DEBUG BEGIN_STMT
  channelIndex = channelIndex + 1;
  # DEBUG BEGIN_STMT
  _4 = (int) moduleIndex;
  _5 = Ftm_Ocu_Ip_gapcxBase[_4];
  _6 = Ftm_Ocu_Ip_GetChannelEventStatus (_5, channelIndex);
  if (_6 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  Ftm_Ocu_Ip_Irq_ProcessChannelInterrupt (moduleIndex, channelIndex);

  <bb 6> :
  # DEBUG BEGIN_STMT
  __asm__ __volatile__(" DSB");
  return;

}


Ftm_Ocu_Ip_Irq_ProcessChannelInterrupt (uint8 InstNum, uint8 ChIdx)
{
  const struct Ftm_Ocu_Ip_ChStateType * const pChannelState;
  boolean HasChEvOccurred;
  boolean IsChEvEnabled;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = (int) InstNum;
  _2 = (int) ChIdx;
  pChannelState = &Ftm_Ocu_Ip_gaxChState[_1][_2];
  # DEBUG BEGIN_STMT
  SchM_Enter_Ocu_OCU_EXCLUSIVE_AREA_15 ();
  # DEBUG BEGIN_STMT
  _3 = (int) InstNum;
  _4 = Ftm_Ocu_Ip_gapcxBase[_3];
  _5 = (int) ChIdx;
  _6 = _4->CONTROLS[_5].CSC;
  _7 = _6 & 64;
  IsChEvEnabled = _7 != 0;
  # DEBUG BEGIN_STMT
  _8 = (int) InstNum;
  _9 = Ftm_Ocu_Ip_gapcxBase[_8];
  _10 = (int) ChIdx;
  _11 = _9->CONTROLS[_10].CSC;
  _12 = _11 & 128;
  HasChEvOccurred = _12 != 0;
  # DEBUG BEGIN_STMT
  SchM_Exit_Ocu_OCU_EXCLUSIVE_AREA_15 ();
  # DEBUG BEGIN_STMT
  Ftm_Ocu_Ip_Irq_ClearChannelInterrupt (InstNum, ChIdx);
  # DEBUG BEGIN_STMT
  if (IsChEvEnabled != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  if (HasChEvOccurred != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _13 = pChannelState->mCallbackFunc;
  if (_13 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _14 = pChannelState->mChannelInit;
  if (_14 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _15 = pChannelState->mCallbackFunc;
  _16 = pChannelState->mCallbackParam;
  _15 (_16);

  <bb 7> :
  return;

}


Ftm_Ocu_Ip_Irq_ClearChannelInterrupt (uint8 InstNum, uint8 NumChannel)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  if (NumChannel <= 7)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  if (InstNum <= 3)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  SchM_Enter_Ocu_OCU_EXCLUSIVE_AREA_10 ();
  # DEBUG BEGIN_STMT
  _1 = (int) InstNum;
  _2 = Ftm_Ocu_Ip_gapcxBase[_1];
  Ftm_Ocu_Ip_ClearChannelEventFlag (_2, NumChannel);
  # DEBUG BEGIN_STMT
  _3 = (int) InstNum;
  _4 = Ftm_Ocu_Ip_gapcxBase[_3];
  Ftm_Ocu_Ip_ClearChannelEventStatus (_4, NumChannel);
  # DEBUG BEGIN_STMT
  SchM_Exit_Ocu_OCU_EXCLUSIVE_AREA_10 ();

  <bb 5> :
  return;

}


Ftm_Ocu_Ip_GetChannelEventStatus (const struct Ftm_Ocu_Ip_xRegLayoutType * const acpcFtmBase, uint8 NumChannel)
{
  boolean D.5904;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = acpcFtmBase->STATUS;
  _2 = (int) NumChannel;
  _3 = _1 >> _2;
  _4 = _3 & 1;
  D.5904 = _4 != 0;
  return D.5904;

}


Ftm_Ocu_Ip_ClearChannelEventStatus (struct Ftm_Ocu_Ip_xRegLayoutType * const acpFtmBase, uint8 NumChannel)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = acpFtmBase->STATUS;
  _2 = (int) NumChannel;
  _3 = 1 << _2;
  _4 = ~_3;
  _5 = _1 & _4;
  acpFtmBase->STATUS = _5;
  return;

}


Ftm_Ocu_Ip_ClearChannelEventFlag (struct Ftm_Ocu_Ip_xRegLayoutType * const acpFtmBase, uint8 NumChannel)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = (int) NumChannel;
  _2 = acpFtmBase->CONTROLS[_1].CSC;
  _3 = (int) NumChannel;
  _4 = _2 & 4294967167;
  acpFtmBase->CONTROLS[_3].CSC = _4;
  return;

}


