Adc_SetChannel (const Adc_GroupType Group, const Adc_GroupDefType * Channel, const uint16 * Delays, const uint32 ChannelUpdateMask, const Adc_ChannelIndexType NumberOfChannel)
{
  Std_ReturnType StatusChecks;
  uint32 Index;
  uint32 u32CoreIdTemp;
  Adc_GroupType GroupIndex;
  Adc_HwUnitType LogicalHwUnitId;
  volatile uint32 u32CoreId;

  <bb 2> :
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  LogicalHwUnitId = 0;
  GroupIndex = 0;
  u32CoreIdTemp = u32CoreId;
  Index = 0;
  u32CoreId.80_2 = u32CoreId;
  StatusChecks = Adc_ValidateCallAndGroup (48, Group, u32CoreId.80_2);
  if (StatusChecks == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 3> :
  u32CoreId.81_3 = u32CoreId;
  _4 = Adc_pCfgPtr[u32CoreId.81_3];
  _5 = _4->pGroupIdToIndexMap;
  _6 = (unsigned int) Group;
  _7 = _6 * 2;
  _8 = _5 + _7;
  GroupIndex = *_8;
  u32CoreId.82_9 = u32CoreId;
  _10 = Adc_pCfgPtr[u32CoreId.82_9];
  _11 = _10->pGroups;
  _12 = (unsigned int) GroupIndex;
  _13 = _12 * 68;
  _14 = _11 + _13;
  LogicalHwUnitId = _14->AdcLogicalUnitId;
  _15 = Adc_ValidatePtr (48, Channel);
  if (_15 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 4> :
  StatusChecks = Adc_CheckSetChannelParams (Group, Delays, ChannelUpdateMask, NumberOfChannel);
  Index = 0;
  goto <bb 10>; [INV]

  <bb 5> :
  _16 = Index * 2;
  _17 = Channel + _16;
  _18 = *_17;
  _19 = Adc_pCfgPtr[u32CoreIdTemp];
  _20 = _19->pAdcIpwConfig;
  _21 = (int) LogicalHwUnitId;
  _22 = _20->Mapping.aAdc_Channels[_21];
  if (_18 >= _22)
    goto <bb 8>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  if (NumberOfChannel > 1)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _23 = Adc_pCfgPtr[u32CoreIdTemp];
  _24 = _23->pAdcIpwConfig;
  _25 = (int) LogicalHwUnitId;
  _26 = _24->ChannelLimitCheckingConfigs[_25];
  _27 = Index * 2;
  _28 = Channel + _27;
  _29 = *_28;
  _30 = (unsigned int) _29;
  _31 = _30 * 12;
  _32 = _26 + _31;
  _33 = _32->bChannelLimitCheckEnabled;
  if (_33 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  Adc_ReportDetError (48, 42);
  StatusChecks = 1;
  goto <bb 11>; [INV]

  <bb 9> :
  Index = Index + 1;

  <bb 10> :
  _34 = (long unsigned int) NumberOfChannel;
  if (Index < _34)
    goto <bb 5>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  if (StatusChecks == 0)
    goto <bb 12>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 12> :
  _35 = (int) Group;
  Adc_aRuntimeGroupChannel[_35].pChannel = Channel;
  _36 = (int) Group;
  Adc_aRuntimeGroupChannel[_36].ChannelCount = NumberOfChannel;
  _37 = (int) Group;
  Adc_aRuntimeGroupChannel[_37].bRuntimeUpdated = 1;
  u32CoreId.83_38 = u32CoreId;
  _39 = Adc_pCfgPtr[u32CoreId.83_38];
  _40 = _39->pAdcIpwConfig;
  _41 = (int) LogicalHwUnitId;
  _42 = _40->ChannelLimitCheckingConfigs[_41];
  _43 = *Channel;
  _44 = (unsigned int) _43;
  _45 = _44 * 12;
  _46 = _42 + _45;
  _47 = (int) Group;
  _48 = _46->bChannelLimitCheckEnabled;
  Adc_aRuntimeGroupChannel[_47].bAdcRuntimeGroupLimitcheck = _48;
  _49 = (int) Group;
  Adc_aRuntimeGroupChannel[_49].pu16Delays = Delays;
  if (NumberOfChannel <= 16)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _50 = (int) Group;
  Adc_aRuntimeGroupChannel[_50].u32Mask = ChannelUpdateMask;
  goto <bb 15>; [INV]

  <bb 14> :
  _51 = (int) Group;
  Adc_aRuntimeGroupChannel[_51].u32Mask = 4294967295;

  <bb 15> :
  return;

}


Adc_SetClockMode (Adc_SelectPrescalerType Prescaler)
{
  uint32 u32CoreIdTemp;
  Std_ReturnType ErrorFound;
  Adc_HwUnitType LogicalHwUnitId;
  Std_ReturnType Ret;
  volatile uint32 u32CoreId;
  Std_ReturnType D.7511;

  <bb 2> :
  Ret = 1;
  ErrorFound = 0;
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreIdTemp = u32CoreId;
  _2 = Adc_CheckSetClockModeCoreAndParam (Prescaler, u32CoreIdTemp);
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 3> :
  LogicalHwUnitId = 0;
  goto <bb 8>; [INV]

  <bb 4> :
  u32CoreId.76_3 = u32CoreId;
  _4 = Adc_pCfgPtr[u32CoreId.76_3];
  _5 = _4->pAdcIpwConfig;
  _6 = (int) LogicalHwUnitId;
  _7 = _5->Mapping.au8Adc_HwUnit[_6];
  if (_7 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  ErrorFound = Adc_ValidateNotBusyNoQueue (LogicalHwUnitId, 37);
  if (ErrorFound == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  goto <bb 9>; [INV]

  <bb 7> :
  LogicalHwUnitId.77_8 = LogicalHwUnitId;
  LogicalHwUnitId = LogicalHwUnitId.77_8 + 1;

  <bb 8> :
  if (LogicalHwUnitId <= 1)
    goto <bb 4>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  if (ErrorFound == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  u32CoreId.78_9 = u32CoreId;
  _10 = Adc_ValidateCheckGroupNotConversion (37, u32CoreId.78_9);
  if (_10 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  u32CoreId.79_11 = u32CoreId;
  Ret = Adc_Ipw_SetClockMode (Prescaler, u32CoreId.79_11);

  <bb 12> :
  D.7511 = Ret;

  <bb 13> :
<L13>:
  return D.7511;

}


Adc_Calibrate (Adc_HwUnitType Unit, struct Adc_CalibrationStatusType * pStatus)
{
  boolean isCalibrateCalled;
  volatile uint32 u32CoreId;

  <bb 2> :
  isCalibrateCalled = 0;
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreId.73_2 = u32CoreId;
  _3 = Adc_ValidateCallAndUnit (41, Unit, u32CoreId.73_2);
  if (_3 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 3> :
  _4 = Adc_ValidatePtr (41, pStatus);
  if (_4 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 4> :
  pStatus->Adc_UnitSelfTestStatus = 1;
  _5 = Adc_ValidateNotBusyNoQueue (Unit, 41);
  if (_5 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  u32CoreId.74_6 = u32CoreId;
  _7 = Adc_ValidateCheckGroupNotConversion (41, u32CoreId.74_6);
  if (_7 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  u32CoreId.75_8 = u32CoreId;
  Adc_Ipw_Calibrate (Unit, pStatus, u32CoreId.75_8);
  isCalibrateCalled = 1;

  <bb 7> :
  if (isCalibrateCalled != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  _9 = pStatus->Adc_UnitSelfTestStatus;
  if (_9 == 1)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  Adc_ReportDetRuntimeError (41, 43);

  <bb 10> :
  return;

}


Adc_ReadRawData (Adc_HwUnitType Unit, const Adc_ChannelType * const ChansArray, uint8 NumItems, Adc_ValueGroupType * const DataBufferPtr)
{
  Std_ReturnType Status;
  const uint32 u32CoreId;
  uint8 i;

  <bb 2> :
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreId.70_2 = u32CoreId;
  _3 = Adc_ValidateCallAndUnit (66, Unit, u32CoreId.70_2);
  if (_3 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 3> :
  _4 = Adc_ValidatePtr (66, DataBufferPtr);
  if (_4 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 4> :
  _5 = Adc_ValidatePtr (66, ChansArray);
  if (_5 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 5> :
  if (NumItems <= 16)
    goto <bb 6>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 6> :
  i = 0;
  goto <bb 13>; [INV]

  <bb 7> :
  Status = 0;
  _6 = (unsigned int) i;
  _7 = _6 * 2;
  _8 = ChansArray + _7;
  _9 = *_8;
  if (_9 <= 29)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _10 = (unsigned int) i;
  _11 = _10 * 2;
  _12 = ChansArray + _11;
  _13 = *_12;
  u32CoreId.71_14 = u32CoreId;
  _15 = (unsigned int) i;
  _16 = _15 * 2;
  _17 = DataBufferPtr + _16;
  Status = Adc_Ipw_GetConvData (Unit, _13, u32CoreId.71_14, _17);
  goto <bb 10>; [INV]

  <bb 9> :
  Status = 1;

  <bb 10> :
  if (Status == 1)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  Adc_ReportDetError (66, 14);

  <bb 12> :
  i.72_18 = i;
  i = i.72_18 + 1;

  <bb 13> :
  if (i < NumItems)
    goto <bb 7>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  Adc_ReportDetError (66, 14);

  <bb 15> :
  return;

}


Adc_GetVersionInfo (struct Std_VersionInfoType * versioninfo)
{
  <bb 2> :
  _1 = Adc_ValidatePtr (10, versioninfo);
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  versioninfo->vendorID = 43;
  versioninfo->moduleID = 123;
  versioninfo->sw_major_version = 1;
  versioninfo->sw_minor_version = 0;
  versioninfo->sw_patch_version = 0;

  <bb 4> :
  return;

}


Adc_GetStreamLastPointer (Adc_GroupType Group, Adc_ValueGroupType * * PtrToSamplePtr)
{
  Std_ReturnType ValidStatus;
  Adc_StreamNumSampleType ResultIndex;
  Adc_StreamNumSampleType NumberOfResults;
  const struct Adc_GroupConfigurationType * pGroupPtr;
  Adc_GroupType GroupIndex;
  volatile uint32 u32CoreId;
  Adc_StreamNumSampleType D.7440;

  <bb 2> :
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  GroupIndex = 0;
  NumberOfResults = 0;
  ResultIndex = 0;
  u32CoreId.63_2 = u32CoreId;
  ValidStatus = Adc_ValidateCallAndGroup (11, Group, u32CoreId.63_2);
  if (ValidStatus == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 3> :
  u32CoreId.64_3 = u32CoreId;
  _4 = Adc_pCfgPtr[u32CoreId.64_3];
  _5 = _4->pGroups;
  _6 = (unsigned int) GroupIndex;
  _7 = _6 * 68;
  pGroupPtr = _5 + _7;
  u32CoreId.65_8 = u32CoreId;
  _9 = Adc_ValidateStateNotIdle (11, Group, u32CoreId.65_8);
  if (_9 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 4> :
  *PtrToSamplePtr = 0B;
  _10 = (int) Group;
  _11 = Adc_aGroupStatus[_10].eConversion;
  if (_11 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 5> :
  _12 = (int) Group;
  _13 = Adc_aGroupStatus[_12].eConversion;
  if (_13 != 1)
    goto <bb 6>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 6> :
  u32CoreId.66_14 = u32CoreId;
  _15 = Adc_pCfgPtr[u32CoreId.66_14];
  _16 = _15->pGroupIdToIndexMap;
  _17 = (unsigned int) Group;
  _18 = _17 * 2;
  _19 = _16 + _18;
  GroupIndex = *_19;
  _20 = (int) Group;
  _21 = Adc_aGroupStatus[_20].ResultIndex;
  if (_21 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  u32CoreId.67_22 = u32CoreId;
  _23 = Adc_pCfgPtr[u32CoreId.67_22];
  _24 = _23->pGroups;
  _25 = (unsigned int) GroupIndex;
  _26 = _25 * 68;
  _27 = _24 + _26;
  _28 = _27->NumSamples;
  ResultIndex = _28 + 65535;
  u32CoreId.68_29 = u32CoreId;
  _30 = Adc_pCfgPtr[u32CoreId.68_29];
  _31 = _30->pGroups;
  _32 = (unsigned int) GroupIndex;
  _33 = _32 * 68;
  _34 = _31 + _33;
  NumberOfResults = _34->NumSamples;
  goto <bb 9>; [INV]

  <bb 8> :
  _35 = (int) Group;
  _36 = Adc_aGroupStatus[_35].ResultIndex;
  ResultIndex = _36 + 65535;
  _37 = (int) Group;
  NumberOfResults = Adc_aGroupStatus[_37].ResultIndex;

  <bb 9> :
  _38 = pGroupPtr->pResultsBufferPtr;
  _39 = (unsigned int) Group;
  _40 = _39 * 4;
  _41 = _38 + _40;
  _42 = *_41;
  _43 = (unsigned int) ResultIndex;
  _44 = _43 * 2;
  _45 = _42 + _44;
  *PtrToSamplePtr = _45;
  u32CoreId.69_46 = u32CoreId;
  Adc_UpdateStatusAfterGetStream (Group, u32CoreId.69_46);
  goto <bb 12>; [INV]

  <bb 10> :
  *PtrToSamplePtr = 0B;
  goto <bb 12>; [INV]

  <bb 11> :
  *PtrToSamplePtr = 0B;

  <bb 12> :
  D.7440 = NumberOfResults;

  <bb 13> :
<L13>:
  return D.7440;

}


Adc_GetGroupStatus (Adc_GroupType Group)
{
  Adc_StatusType eTempReturn;
  volatile uint32 u32CoreId;
  Adc_StatusType D.7425;

  <bb 2> :
  eTempReturn = 0;
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreId.62_2 = u32CoreId;
  _3 = Adc_ValidateCallAndGroup (9, Group, u32CoreId.62_2);
  if (_3 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _4 = (int) Group;
  eTempReturn = Adc_aGroupStatus[_4].eConversion;

  <bb 4> :
  D.7425 = eTempReturn;

  <bb 5> :
<L2>:
  return D.7425;

}


Adc_DisableGroupNotification (Adc_GroupType Group)
{
  volatile uint32 u32CoreId;

  <bb 2> :
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreId.60_2 = u32CoreId;
  _3 = Adc_ValidateCallAndGroup (8, Group, u32CoreId.60_2);
  if (_3 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  u32CoreId.61_4 = u32CoreId;
  _5 = Adc_NotifyCapablity (8, Group, u32CoreId.61_4);
  if (_5 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = (int) Group;
  Adc_aGroupStatus[_6].eNotification = 0;

  <bb 5> :
  return;

}


Adc_EnableGroupNotification (Adc_GroupType Group)
{
  volatile uint32 u32CoreId;

  <bb 2> :
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreId.58_2 = u32CoreId;
  _3 = Adc_ValidateCallAndGroup (7, Group, u32CoreId.58_2);
  if (_3 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  u32CoreId.59_4 = u32CoreId;
  _5 = Adc_NotifyCapablity (7, Group, u32CoreId.59_4);
  if (_5 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = (int) Group;
  Adc_aGroupStatus[_6].eNotification = 1;

  <bb 5> :
  return;

}


Adc_DisableHardwareTrigger (Adc_GroupType Group)
{
  Adc_HwUnitType LogicalHwUnitId;
  Adc_GroupType GroupIndex;
  volatile uint32 u32CoreId;

  <bb 2> :
  GroupIndex = 0;
  LogicalHwUnitId = 0;
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreId.52_2 = u32CoreId;
  _3 = Adc_ValidateCallAndGroup (6, Group, u32CoreId.52_2);
  if (_3 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  u32CoreId.53_4 = u32CoreId;
  _5 = Adc_ValidateStateNotIdle (6, Group, u32CoreId.53_4);
  if (_5 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  u32CoreId.54_6 = u32CoreId;
  _7 = Adc_ValidateExtraParams (6, 10, Group, u32CoreId.54_6);
  if (_7 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  u32CoreId.55_8 = u32CoreId;
  _9 = Adc_pCfgPtr[u32CoreId.55_8];
  _10 = _9->pGroupIdToIndexMap;
  _11 = (unsigned int) Group;
  _12 = _11 * 2;
  _13 = _10 + _12;
  GroupIndex = *_13;
  u32CoreId.56_14 = u32CoreId;
  _15 = Adc_pCfgPtr[u32CoreId.56_14];
  _16 = _15->pGroups;
  _17 = (unsigned int) GroupIndex;
  _18 = _17 * 68;
  _19 = _16 + _18;
  LogicalHwUnitId = _19->AdcLogicalUnitId;
  Adc_UpdateStatusDisableHardware (Group, LogicalHwUnitId);
  u32CoreId.57_20 = u32CoreId;
  Adc_Ipw_DisableHardwareTrigger (Group, LogicalHwUnitId, u32CoreId.57_20);

  <bb 6> :
  return;

}


Adc_EnableHardwareTrigger (Adc_GroupType Group)
{
  Std_ReturnType ValidStatus;
  Adc_HwUnitType LogicalHwUnitId;
  Adc_GroupType GroupIndex;
  volatile uint32 u32CoreId;

  <bb 2> :
  GroupIndex = 0;
  LogicalHwUnitId = 0;
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreId.46_2 = u32CoreId;
  _3 = Adc_ValidateCallAndGroup (5, Group, u32CoreId.46_2);
  if (_3 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  u32CoreId.47_4 = u32CoreId;
  _5 = Adc_pCfgPtr[u32CoreId.47_4];
  _6 = _5->pGroupIdToIndexMap;
  _7 = (unsigned int) Group;
  _8 = _7 * 2;
  _9 = _6 + _8;
  GroupIndex = *_9;
  u32CoreId.48_10 = u32CoreId;
  _11 = Adc_ValidateStateEnableHwTriggNotBusy (Group, u32CoreId.48_10);
  if (_11 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  u32CoreId.49_12 = u32CoreId;
  _13 = Adc_ValidateExtraParams (5, 11, Group, u32CoreId.49_12);
  if (_13 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  u32CoreId.50_14 = u32CoreId;
  _15 = Adc_pCfgPtr[u32CoreId.50_14];
  _16 = _15->pGroups;
  _17 = (unsigned int) GroupIndex;
  _18 = _17 * 68;
  _19 = _16 + _18;
  LogicalHwUnitId = _19->AdcLogicalUnitId;
  Adc_UpdateStatusEnableHardware (Group, LogicalHwUnitId);
  u32CoreId.51_20 = u32CoreId;
  ValidStatus = Adc_Ipw_EnableHardwareTrigger (Group, LogicalHwUnitId, u32CoreId.51_20);
  if (ValidStatus == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  Adc_ReportDetRuntimeError (5, 11);

  <bb 7> :
  return;

}


Adc_ReadGroup (Adc_GroupType Group, Adc_ValueGroupType * DataBufferPtr)
{
  boolean bFlag;
  Std_ReturnType GroupRet;
  volatile uint32 u32CoreId;
  Std_ReturnType D.7340;

  <bb 2> :
  GroupRet = 1;
  bFlag = 1;
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreId.39_2 = u32CoreId;
  _3 = Adc_ValidateCallAndGroup (4, Group, u32CoreId.39_2);
  if (_3 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  _4 = Adc_ValidatePtr (4, DataBufferPtr);
  if (_4 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  u32CoreId.40_5 = u32CoreId;
  _6 = Adc_ValidateStateNotIdle (4, Group, u32CoreId.40_5);
  if (_6 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  u32CoreId.41_7 = u32CoreId;
  GroupRet = Adc_Ipw_ReadGroup (Group, DataBufferPtr, &bFlag, u32CoreId.41_7);
  if (GroupRet == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  bFlag.42_8 = bFlag;
  _9 = ~bFlag.42_8;
  if (_9 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  bFlag.43_10 = bFlag;
  u32CoreId.44_11 = u32CoreId;
  Adc_UpdateStatusReadGroup (Group, bFlag.43_10, u32CoreId.44_11);

  <bb 8> :
  D.7340 = GroupRet;
  bFlag = {CLOBBER};

  <bb 9> :
<L10>:
  return D.7340;

}


Adc_StopGroupConversion (Adc_GroupType Group)
{
  Adc_GroupType GroupIndex;
  volatile uint32 u32CoreId;
  Adc_HwUnitType LogicalHwUnitId;

  <bb 2> :
  LogicalHwUnitId = 0;
  GroupIndex = 0;
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreId.31_2 = u32CoreId;
  _3 = Adc_ValidateCallAndGroup (3, Group, u32CoreId.31_2);
  if (_3 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  u32CoreId.32_4 = u32CoreId;
  _5 = Adc_ValidateStateNotIdle (3, Group, u32CoreId.32_4);
  if (_5 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  u32CoreId.33_6 = u32CoreId;
  _7 = Adc_ValidateExtraParams (3, 2, Group, u32CoreId.33_6);
  if (_7 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  u32CoreId.34_8 = u32CoreId;
  _9 = Adc_pCfgPtr[u32CoreId.34_8];
  _10 = _9->pGroupIdToIndexMap;
  _11 = (unsigned int) Group;
  _12 = _11 * 2;
  _13 = _10 + _12;
  GroupIndex = *_13;
  u32CoreId.35_14 = u32CoreId;
  _15 = Adc_pCfgPtr[u32CoreId.35_14];
  _16 = _15->pGroups;
  _17 = (unsigned int) GroupIndex;
  _18 = _17 * 68;
  _19 = _16 + _18;
  LogicalHwUnitId = _19->AdcLogicalUnitId;
  u32CoreId.36_20 = u32CoreId;
  Adc_UpdateStatusStopConversion (Group, LogicalHwUnitId, u32CoreId.36_20);

  <bb 6> :
  return;

}


Adc_StartGroupConversion (Adc_GroupType Group)
{
  Adc_HwUnitType LogicalHwUnitId;
  Adc_GroupType GroupIndex;
  volatile uint32 u32CoreId;

  <bb 2> :
  GroupIndex = 0;
  LogicalHwUnitId = 0;
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreId.25_2 = u32CoreId;
  _3 = Adc_ValidateCallAndGroup (2, Group, u32CoreId.25_2);
  if (_3 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  u32CoreId.26_4 = u32CoreId;
  _5 = Adc_pCfgPtr[u32CoreId.26_4];
  _6 = _5->pGroupIdToIndexMap;
  _7 = (unsigned int) Group;
  _8 = _7 * 2;
  _9 = _6 + _8;
  GroupIndex = *_9;
  u32CoreId.27_10 = u32CoreId;
  _11 = Adc_ValidateStateStartGroupConvNotBusy (Group, u32CoreId.27_10);
  if (_11 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  u32CoreId.28_12 = u32CoreId;
  _13 = Adc_ValidateExtraParams (2, 7, Group, u32CoreId.28_12);
  if (_13 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  u32CoreId.29_14 = u32CoreId;
  _15 = Adc_pCfgPtr[u32CoreId.29_14];
  _16 = _15->pGroups;
  _17 = (unsigned int) GroupIndex;
  _18 = _17 * 68;
  _19 = _16 + _18;
  LogicalHwUnitId = _19->AdcLogicalUnitId;
  u32CoreId.30_20 = u32CoreId;
  Adc_UpdateStatusStartConversion (Group, LogicalHwUnitId, u32CoreId.30_20);

  <bb 6> :
  return;

}


Adc_DeInit ()
{
  Std_ReturnType ValidStatus;
  Std_ReturnType TempReturn;
  uint32 u32CoreIdTemp;
  Std_ReturnType ValidCoreId;
  Adc_HwUnitType LogicalHwUnitId;
  volatile uint32 u32CoreId;

  <bb 2> :
  LogicalHwUnitId = 0;
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreIdTemp = u32CoreId;
  u32CoreId.15_2 = u32CoreId;
  ValidStatus = Adc_ValidateGloballCall (1, u32CoreId.15_2);
  if (ValidStatus == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 3> :
  u32CoreId.16_3 = u32CoreId;
  _4 = Adc_pCfgPtr[u32CoreId.16_3];
  ValidCoreId = Adc_CheckCurrentCoreId (_4, u32CoreIdTemp);
  if (ValidCoreId == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 4> :
  u32CoreId.17_5 = u32CoreId;
  ValidStatus = Adc_ValidateDeInitNotBusy (u32CoreId.17_5);
  if (ValidStatus == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 5> :
  u32CoreId.18_6 = u32CoreId;
  TempReturn = Adc_Ipw_DeInit (u32CoreId.18_6);
  if (TempReturn == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  Adc_ReportDetRuntimeError (1, 43);

  <bb 7> :
  LogicalHwUnitId = 0;
  goto <bb 11>; [INV]

  <bb 8> :
  u32CoreId.19_7 = u32CoreId;
  _8 = Adc_pCfgPtr[u32CoreId.19_7];
  _9 = _8->pAdcIpwConfig;
  _10 = (int) LogicalHwUnitId;
  _11 = _9->Mapping.au8Adc_HwUnit[_10];
  if (_11 == 1)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _12 = (int) LogicalHwUnitId;
  Adc_aUnitStatus[_12].u8Sc1Used = 0;

  <bb 10> :
  LogicalHwUnitId.20_13 = LogicalHwUnitId;
  LogicalHwUnitId = LogicalHwUnitId.20_13 + 1;

  <bb 11> :
  if (LogicalHwUnitId <= 1)
    goto <bb 8>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  u32CoreId.21_14 = u32CoreId;
  Adc_pCfgPtr[u32CoreId.21_14] = 0B;
  goto <bb 14>; [INV]

  <bb 13> :
  Adc_ReportDetError (1, 14);

  <bb 14> :
  u32CoreId.22_15 = u32CoreId;
  Adc_EndValidateGloballCall (ValidStatus, 1, u32CoreId.22_15);
  return;

}


Adc_SetupResultBuffer (Adc_GroupType Group, Adc_ValueGroupType * const DataBufferPtr)
{
  const struct Adc_GroupConfigurationType * pGroupPtr;
  Std_ReturnType TempReturn;
  Adc_GroupType GroupIndex;
  volatile uint32 u32CoreId;
  Std_ReturnType D.7162;

  <bb 2> :
  TempReturn = 1;
  pGroupPtr = 0B;
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreId.12_2 = u32CoreId;
  _3 = Adc_ValidateCallAndGroup (12, Group, u32CoreId.12_2);
  if (_3 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  u32CoreId.13_4 = u32CoreId;
  _5 = Adc_pCfgPtr[u32CoreId.13_4];
  _6 = _5->pGroupIdToIndexMap;
  _7 = (unsigned int) Group;
  _8 = _7 * 2;
  _9 = _6 + _8;
  GroupIndex = *_9;
  _10 = Adc_ValidatePtr (12, DataBufferPtr);
  if (_10 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _11 = Adc_ValidateSetupBufferNotBusy (Group);
  if (_11 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  u32CoreId.14_12 = u32CoreId;
  _13 = Adc_pCfgPtr[u32CoreId.14_12];
  _14 = _13->pGroups;
  _15 = (unsigned int) GroupIndex;
  _16 = _15 * 68;
  pGroupPtr = _14 + _16;
  _17 = pGroupPtr->pResultsBufferPtr;
  _18 = (unsigned int) Group;
  _19 = _18 * 4;
  _20 = _17 + _19;
  *_20 = DataBufferPtr;
  TempReturn = 0;

  <bb 6> :
  D.7162 = TempReturn;

  <bb 7> :
<L6>:
  return D.7162;

}


Adc_Init (const struct Adc_ConfigType * ConfigPtr)
{
  Std_ReturnType ValidStatus;
  Std_ReturnType TimeOutStatus;
  Std_ReturnType ValidCoreId;
  uint32 u32CoreIdTemp;
  volatile uint32 u32CoreId;

  <bb 2> :
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreIdTemp = u32CoreId;
  u32CoreId.1_2 = u32CoreId;
  ValidStatus = Adc_ValidateGloballCall (0, u32CoreId.1_2);
  if (ValidStatus == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  ValidStatus = Adc_ValidatePtrInit (ConfigPtr);
  if (ValidStatus == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  u32CoreId.2_3 = u32CoreId;
  ValidCoreId = Adc_CheckCurrentCoreId (ConfigPtr, u32CoreId.2_3);
  if (ValidCoreId == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  u32CoreId.3_4 = u32CoreId;
  Adc_pCfgPtr[u32CoreId.3_4] = ConfigPtr;
  u32CoreId.4_5 = u32CoreId;
  Adc_InitUnitStatus (u32CoreId.4_5);
  u32CoreId.5_6 = u32CoreId;
  Adc_InitGroupsStatus (u32CoreId.5_6);
  u32CoreId.6_7 = u32CoreId;
  _8 = Adc_pCfgPtr[u32CoreId.6_7];
  _9 = _8->pAdcIpwConfig;
  TimeOutStatus = Adc_Ipw_Init (_9, u32CoreIdTemp);
  if (TimeOutStatus == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  Adc_ReportDetRuntimeError (0, 43);
  goto <bb 8>; [INV]

  <bb 7> :
  ValidStatus = 1;
  Adc_ReportDetError (0, 14);

  <bb 8> :
  if (ValidStatus == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  u32CoreId.7_10 = u32CoreId;
  Adc_EndValidateGloballCall (ValidStatus, 0, u32CoreId.7_10);

  <bb 10> :
  return;

}


Adc_CheckSetClockModeCoreAndParam (const Adc_SelectPrescalerType Prescaler, const uint32 u32CoreId)
{
  Std_ReturnType ValidCoreId;
  boolean Valid;
  boolean D.7523;

  <bb 2> :
  Valid = 0;
  ValidCoreId = 1;
  _1 = Adc_pCfgPtr[u32CoreId];
  if (_1 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  Adc_ReportDetError (37, 10);
  goto <bb 10>; [INV]

  <bb 4> :
  _2 = Adc_pCfgPtr[u32CoreId];
  ValidCoreId = Adc_CheckCurrentCoreId (_2, u32CoreId);
  if (ValidCoreId == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  Adc_ReportDetError (37, 14);
  goto <bb 10>; [INV]

  <bb 6> :
  if (Prescaler != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  if (Prescaler != 1)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  Adc_ReportDetError (37, 41);
  goto <bb 10>; [INV]

  <bb 9> :
  Valid = 1;

  <bb 10> :
  D.7523 = Valid;

  <bb 11> :
<L10>:
  return D.7523;

}


Adc_CheckSetChannelParams (const Adc_GroupType Group, const uint16 * Delays, const uint32 ChannelUpdateMask, const Adc_ChannelIndexType NumberOfChannel)
{
  const Adc_GroupType GroupIndex;
  Std_ReturnType StatusChecks;
  const uint32 u32CoreIdTemp;
  volatile uint32 u32CoreId;
  Std_ReturnType D.7555;

  <bb 2> :
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreIdTemp = u32CoreId;
  StatusChecks = 0;
  u32CoreId.84_2 = u32CoreId;
  _3 = Adc_pCfgPtr[u32CoreId.84_2];
  _4 = _3->pGroupIdToIndexMap;
  _5 = (unsigned int) Group;
  _6 = _5 * 2;
  _7 = _4 + _6;
  GroupIndex = *_7;
  if (NumberOfChannel == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  Adc_ReportDetError (48, 42);
  StatusChecks = 1;
  goto <bb 14>; [INV]

  <bb 4> :
  _8 = (unsigned int) NumberOfChannel;
  _9 = _8 + 4294967295;
  _10 = ChannelUpdateMask >> _9;
  _11 = _10 & 1;
  if (_11 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _12 = Adc_pCfgPtr[u32CoreIdTemp];
  _13 = _12->pGroups;
  _14 = (unsigned int) GroupIndex;
  _15 = _14 * 68;
  _16 = _13 + _15;
  _17 = _16->AssignedChannelCount;
  if (NumberOfChannel != _17)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  Adc_ReportDetError (48, 42);
  goto <bb 14>; [INV]

  <bb 7> :
  _18 = Adc_ValidatePtr (48, Delays);
  if (_18 == 1)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  _19 = Adc_pCfgPtr[u32CoreIdTemp];
  _20 = _19->pGroups;
  _21 = (unsigned int) GroupIndex;
  _22 = _21 * 68;
  _23 = _20 + _22;
  _24 = _23->pAdcIpwGroupConfig;
  _25 = _24->AdcGroupEnableChannelDelays;
  if (_25 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _26 = Adc_pCfgPtr[u32CoreIdTemp];
  _27 = _26->pGroups;
  _28 = (unsigned int) GroupIndex;
  _29 = _28 * 68;
  _30 = _27 + _29;
  _31 = _30->AssignedChannelCount;
  if (NumberOfChannel != _31)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  Adc_ReportDetError (48, 20);
  goto <bb 14>; [INV]

  <bb 11> :
  _32 = Adc_pCfgPtr[u32CoreIdTemp];
  _33 = _32->pGroups;
  _34 = (unsigned int) GroupIndex;
  _35 = _34 * 68;
  _36 = _33 + _35;
  _37 = _36->u8AdcWithoutInterrupt;
  if (_37 == 1)
    goto <bb 12>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 12> :
  if (NumberOfChannel > 16)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  Adc_ReportDetError (48, 42);
  StatusChecks = 1;

  <bb 14> :
  D.7555 = StatusChecks;

  <bb 15> :
<L17>:
  return D.7555;

}


Adc_UpdateStatusAfterGetStream (Adc_GroupType Group, uint32 u32CoreId)
{
  Adc_GroupType GroupIndex;

  <bb 2> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  _6 = (int) Group;
  _7 = Adc_aGroupStatus[_6].eConversion;
  if (_7 == 2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _8 = (int) Group;
  Adc_aGroupStatus[_8].eConversion = 1;

  <bb 4> :
  _9 = (int) Group;
  _10 = Adc_aGroupStatus[_9].eConversion;
  if (_10 == 3)
    goto <bb 5>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 5> :
  _11 = Adc_pCfgPtr[u32CoreId];
  _12 = _11->pGroups;
  _13 = (unsigned int) GroupIndex;
  _14 = _13 * 68;
  _15 = _12 + _14;
  _16 = _15->eTriggerSource;
  if (_16 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  _17 = Adc_pCfgPtr[u32CoreId];
  _18 = _17->pGroups;
  _19 = (unsigned int) GroupIndex;
  _20 = _19 * 68;
  _21 = _18 + _20;
  _22 = _21->eMode;
  if (_22 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _23 = Adc_pCfgPtr[u32CoreId];
  _24 = _23->pGroups;
  _25 = (unsigned int) GroupIndex;
  _26 = _25 * 68;
  _27 = _24 + _26;
  _28 = _27->eMode;
  if (_28 == 1)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  _29 = Adc_pCfgPtr[u32CoreId];
  _30 = _29->pGroups;
  _31 = (unsigned int) GroupIndex;
  _32 = _31 * 68;
  _33 = _30 + _32;
  _34 = _33->eAccessMode;
  if (_34 == 1)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _35 = Adc_pCfgPtr[u32CoreId];
  _36 = _35->pGroups;
  _37 = (unsigned int) GroupIndex;
  _38 = _37 * 68;
  _39 = _36 + _38;
  _40 = _39->eBufferMode;
  if (_40 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _41 = (int) Group;
  Adc_aGroupStatus[_41].eConversion = 0;
  goto <bb 12>; [INV]

  <bb 11> :
  _42 = (int) Group;
  Adc_aGroupStatus[_42].eConversion = 1;

  <bb 12> :
  goto <bb 17>; [INV]

  <bb 13> :
  _43 = Adc_pCfgPtr[u32CoreId];
  _44 = _43->pGroups;
  _45 = (unsigned int) GroupIndex;
  _46 = _45 * 68;
  _47 = _44 + _46;
  _48 = _47->eAccessMode;
  if (_48 == 1)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  _49 = Adc_pCfgPtr[u32CoreId];
  _50 = _49->pGroups;
  _51 = (unsigned int) GroupIndex;
  _52 = _51 * 68;
  _53 = _50 + _52;
  _54 = _53->eBufferMode;
  if (_54 == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _55 = (int) Group;
  Adc_aGroupStatus[_55].eConversion = 0;
  goto <bb 17>; [INV]

  <bb 16> :
  _56 = (int) Group;
  Adc_aGroupStatus[_56].eConversion = 1;

  <bb 17> :
  return;

}


Adc_UpdateStatusDisableHardware (Adc_GroupType Group, Adc_HwUnitType Unit)
{
  <bb 2> :
  _1 = (int) Group;
  Adc_aGroupStatus[_1].eNotification = 0;
  _2 = (int) Group;
  Adc_aRuntimeGroupChannel[_2].u32Mask = 4294967295;
  _3 = (int) Group;
  Adc_aGroupStatus[_3].eConversion = 0;
  _4 = (int) Group;
  Adc_aGroupStatus[_4].eHwTriggering = 0;
  _5 = (int) Unit;
  Adc_aUnitStatus[_5].OngoingHwGroup = 65535;
  return;

}


Adc_UpdateStatusEnableHardware (Adc_GroupType Group, Adc_HwUnitType Unit)
{
  <bb 2> :
  _1 = (int) Unit;
  Adc_aUnitStatus[_1].OngoingHwGroup = Group;
  _2 = (int) Group;
  Adc_aGroupStatus[_2].eConversion = 1;
  _3 = (int) Group;
  Adc_aGroupStatus[_3].eHwTriggering = 1;
  _4 = (int) Group;
  Adc_aGroupStatus[_4].ResultIndex = 0;
  return;

}


Adc_UpdateStatusReadGroupInt (const Adc_GroupType Group, uint32 u32CoreId)
{
  Adc_GroupType GroupIndex;

  <bb 2> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  _6 = (int) Group;
  _7 = Adc_aGroupStatus[_6].eConversion;
  if (_7 == 2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _8 = (int) Group;
  Adc_aGroupStatus[_8].eConversion = 1;
  goto <bb 18>; [INV]

  <bb 4> :
  _9 = (int) Group;
  _10 = Adc_aGroupStatus[_9].eConversion;
  if (_10 == 3)
    goto <bb 5>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 5> :
  _11 = Adc_pCfgPtr[u32CoreId];
  _12 = _11->pGroups;
  _13 = (unsigned int) GroupIndex;
  _14 = _13 * 68;
  _15 = _12 + _14;
  _16 = _15->eTriggerSource;
  if (_16 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  _17 = Adc_pCfgPtr[u32CoreId];
  _18 = _17->pGroups;
  _19 = (unsigned int) GroupIndex;
  _20 = _19 * 68;
  _21 = _18 + _20;
  _22 = _21->eMode;
  if (_22 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _23 = Adc_pCfgPtr[u32CoreId];
  _24 = _23->pGroups;
  _25 = (unsigned int) GroupIndex;
  _26 = _25 * 68;
  _27 = _24 + _26;
  _28 = _27->eMode;
  if (_28 == 1)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  _29 = Adc_pCfgPtr[u32CoreId];
  _30 = _29->pGroups;
  _31 = (unsigned int) GroupIndex;
  _32 = _31 * 68;
  _33 = _30 + _32;
  _34 = _33->eAccessMode;
  if (_34 == 1)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _35 = Adc_pCfgPtr[u32CoreId];
  _36 = _35->pGroups;
  _37 = (unsigned int) GroupIndex;
  _38 = _37 * 68;
  _39 = _36 + _38;
  _40 = _39->eBufferMode;
  if (_40 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _41 = (int) Group;
  Adc_aGroupStatus[_41].eConversion = 0;
  goto <bb 12>; [INV]

  <bb 11> :
  _42 = (int) Group;
  Adc_aGroupStatus[_42].eConversion = 1;

  <bb 12> :
  goto <bb 17>; [INV]

  <bb 13> :
  _43 = Adc_pCfgPtr[u32CoreId];
  _44 = _43->pGroups;
  _45 = (unsigned int) GroupIndex;
  _46 = _45 * 68;
  _47 = _44 + _46;
  _48 = _47->eAccessMode;
  if (_48 == 1)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  _49 = Adc_pCfgPtr[u32CoreId];
  _50 = _49->pGroups;
  _51 = (unsigned int) GroupIndex;
  _52 = _51 * 68;
  _53 = _50 + _52;
  _54 = _53->eBufferMode;
  if (_54 == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _55 = (int) Group;
  Adc_aGroupStatus[_55].eConversion = 0;
  goto <bb 17>; [INV]

  <bb 16> :
  _56 = (int) Group;
  Adc_aGroupStatus[_56].eConversion = 1;

  <bb 17> :

  <bb 18> :
  return;

}


Adc_UpdateSwQueueIndexNoInt (const Adc_GroupType Group, uint32 u32CoreId)
{
  Adc_QueueIndexType NumOfSwNormalQueue;
  Adc_QueueIndexType SwNormalQueueIndex;
  Adc_HwUnitType LogicalHwUnitId;
  Adc_GroupType GroupIndex;

  <bb 2> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  _6 = Adc_pCfgPtr[u32CoreId];
  _7 = _6->pGroups;
  _8 = (unsigned int) GroupIndex;
  _9 = _8 * 68;
  _10 = _7 + _9;
  LogicalHwUnitId = _10->AdcLogicalUnitId;
  _11 = (int) LogicalHwUnitId;
  _12 = Adc_aUnitStatus[_11].SwNormalQueueIndex;
  if (_12 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 3> :
  _13 = (int) LogicalHwUnitId;
  NumOfSwNormalQueue = Adc_aUnitStatus[_13].SwNormalQueueIndex;
  SwNormalQueueIndex = 0;
  goto <bb 7>; [INV]

  <bb 4> :
  _14 = (int) LogicalHwUnitId;
  _15 = (int) SwNormalQueueIndex;
  _16 = Adc_aUnitStatus[_14].SwNormalQueue[_15];
  if (Group == _16)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  Adc_RemoveFromQueue (LogicalHwUnitId, SwNormalQueueIndex);
  goto <bb 8>; [INV]

  <bb 6> :
  SwNormalQueueIndex.45_17 = SwNormalQueueIndex;
  SwNormalQueueIndex = SwNormalQueueIndex.45_17 + 1;

  <bb 7> :
  if (SwNormalQueueIndex < NumOfSwNormalQueue)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  if (SwNormalQueueIndex == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _18 = (int) LogicalHwUnitId;
  _19 = Adc_aUnitStatus[_18].SwNormalQueueIndex;
  if (_19 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  Adc_Ipw_StartNormalConversion (LogicalHwUnitId, u32CoreId);

  <bb 11> :
  return;

}


Adc_UpdateStatusReadGroupNoInt (const Adc_GroupType Group, const boolean bFlag, uint32 u32CoreId)
{
  Adc_GroupType GroupIndex;

  <bb 2> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  _6 = (int) Group;
  Adc_aGroupStatus[_6].eAlreadyConverted = 1;
  if (bFlag != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  _7 = Adc_pCfgPtr[u32CoreId];
  _8 = _7->pGroups;
  _9 = (unsigned int) GroupIndex;
  _10 = _9 * 68;
  _11 = _8 + _10;
  _12 = _11->eMode;
  if (_12 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _13 = (int) Group;
  Adc_aGroupStatus[_13].eConversion = 1;
  goto <bb 9>; [INV]

  <bb 5> :
  _14 = Adc_pCfgPtr[u32CoreId];
  _15 = _14->pGroups;
  _16 = (unsigned int) GroupIndex;
  _17 = _16 * 68;
  _18 = _15 + _17;
  _19 = _18->eTriggerSource;
  if (_19 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 6> :
  _20 = (int) Group;
  Adc_aGroupStatus[_20].eConversion = 0;
  Adc_UpdateSwQueueIndexNoInt (Group, u32CoreId);
  goto <bb 9>; [INV]

  <bb 7> :
  _21 = Adc_pCfgPtr[u32CoreId];
  _22 = _21->pGroups;
  _23 = (unsigned int) GroupIndex;
  _24 = _23 * 68;
  _25 = _22 + _24;
  _26 = _25->eMode;
  if (_26 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _27 = (int) Group;
  Adc_aGroupStatus[_27].eConversion = 1;

  <bb 9> :
  return;

}


Adc_UpdateStatusReadGroup (const Adc_GroupType Group, const boolean bFlag, uint32 u32CoreId)
{
  Adc_GroupType GroupIndex;

  <bb 2> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  _6 = Adc_pCfgPtr[u32CoreId];
  _7 = _6->pGroups;
  _8 = (unsigned int) GroupIndex;
  _9 = _8 * 68;
  _10 = _7 + _9;
  _11 = _10->u8AdcWithoutInterrupt;
  if (_11 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  Adc_UpdateStatusReadGroupNoInt (Group, bFlag, u32CoreId);
  goto <bb 5>; [INV]

  <bb 4> :
  Adc_UpdateStatusReadGroupInt (Group, u32CoreId);

  <bb 5> :
  return;

}


Adc_UpdateStatusStopConversion (Adc_GroupType Group, Adc_HwUnitType Unit, uint32 u32CoreId)
{
  Adc_StatusType eConversion;
  Adc_StreamBufferModeType eBufferMode;
  Adc_GroupAccessModeType eAccessMode;
  Adc_GroupConvModeType eMode;
  Std_ReturnType TimeOutStatus;
  Adc_QueueIndexType RemovedPos;
  Adc_GroupType GroupIndex;

  <bb 2> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  RemovedPos = 0;
  TimeOutStatus = 0;
  _6 = (int) Group;
  Adc_aGroupStatus[_6].bLimitCheckFailed = 0;
  _7 = Adc_pCfgPtr[u32CoreId];
  _8 = _7->pGroups;
  _9 = (unsigned int) GroupIndex;
  _10 = _9 * 68;
  _11 = _8 + _10;
  eMode = _11->eMode;
  _12 = Adc_pCfgPtr[u32CoreId];
  _13 = _12->pGroups;
  _14 = (unsigned int) GroupIndex;
  _15 = _14 * 68;
  _16 = _13 + _15;
  eAccessMode = _16->eAccessMode;
  _17 = Adc_pCfgPtr[u32CoreId];
  _18 = _17->pGroups;
  _19 = (unsigned int) GroupIndex;
  _20 = _19 * 68;
  _21 = _18 + _20;
  eBufferMode = _21->eBufferMode;
  _22 = (int) Group;
  eConversion = Adc_aGroupStatus[_22].eConversion;
  _23 = (int) Group;
  Adc_aGroupStatus[_23].ResultIndex = 0;
  _24 = (int) Group;
  Adc_aGroupStatus[_24].eNotification = 0;
  _25 = (int) Group;
  Adc_aRuntimeGroupChannel[_25].u32Mask = 4294967295;
  if (eMode == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (eAccessMode == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  if (eBufferMode == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (eConversion == 3)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _26 = (int) Group;
  Adc_aGroupStatus[_26].eConversion = 0;
  goto <bb 12>; [INV]

  <bb 7> :
  TimeOutStatus = Adc_StopSwGroupConversion (&RemovedPos, Group, Unit, u32CoreId);
  _27 = (int) Group;
  Adc_aGroupStatus[_27].eConversion = 0;
  RemovedPos.37_28 = RemovedPos;
  if (RemovedPos.37_28 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  _29 = (int) Unit;
  _30 = Adc_aUnitStatus[_29].SwNormalQueueIndex;
  if (_30 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  Adc_Ipw_StartNormalConversion (Unit, u32CoreId);

  <bb 10> :
  if (TimeOutStatus == 1)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  Adc_ReportDetRuntimeError (3, 43);

  <bb 12> :
  RemovedPos = {CLOBBER};
  return;

}


Adc_StopSwGroupConversion (Adc_QueueIndexType * RemovedPos, Adc_GroupType Group, Adc_HwUnitType Unit, uint32 u32CoreId)
{
  Adc_QueueIndexType NumOfSwNormalQueue;
  Adc_QueueIndexType SwNormalQueueIndex;
  Std_ReturnType TimeOutStatus;
  Std_ReturnType D.7329;

  <bb 2> :
  TimeOutStatus = 0;
  _1 = (int) Unit;
  _2 = Adc_aUnitStatus[_1].SwNormalQueueIndex;
  *RemovedPos = _2;
  _3 = (int) Unit;
  NumOfSwNormalQueue = Adc_aUnitStatus[_3].SwNormalQueueIndex;
  SwNormalQueueIndex = 0;
  goto <bb 8>; [INV]

  <bb 3> :
  _4 = (int) Unit;
  _5 = (int) SwNormalQueueIndex;
  _6 = Adc_aUnitStatus[_4].SwNormalQueue[_5];
  if (Group == _6)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  *RemovedPos = SwNormalQueueIndex;
  if (SwNormalQueueIndex == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  TimeOutStatus = Adc_Ipw_StopCurrentConversion (Unit, Group, u32CoreId);

  <bb 6> :
  Adc_RemoveFromQueue (Unit, SwNormalQueueIndex);

  <bb 7> :
  SwNormalQueueIndex.38_7 = SwNormalQueueIndex;
  SwNormalQueueIndex = SwNormalQueueIndex.38_7 + 1;

  <bb 8> :
  if (SwNormalQueueIndex < NumOfSwNormalQueue)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.7329 = TimeOutStatus;

  <bb 10> :
<L7>:
  return D.7329;

}


Adc_UpdateStatusStartConversion (const Adc_GroupType Group, const Adc_HwUnitType Unit, uint32 u32CoreId)
{
  Std_ReturnType TimeOutStatus;
  Adc_QueueIndexType SwNormalQueueIndex;
  Adc_QueueIndexType qPtr;

  <bb 2> :
  qPtr = 0;
  TimeOutStatus = 0;
  _1 = (int) Group;
  Adc_aGroupStatus[_1].eConversion = 1;
  _2 = (int) Group;
  Adc_aGroupStatus[_2].ResultIndex = 0;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01 ();
  _3 = (int) Unit;
  qPtr = Adc_aUnitStatus[_3].SwNormalQueueIndex;
  if (qPtr != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _4 = (int) Unit;
  _5 = (int) qPtr;
  Adc_aUnitStatus[_4].SwNormalQueue[_5] = Group;
  _6 = (int) Unit;
  _7 = Adc_aUnitStatus[_6].SwNormalQueueIndex;
  _8 = _7;
  _9 = _8 + 1;
  Adc_aUnitStatus[_6].SwNormalQueueIndex = _9;

  <bb 4> :
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01 ();
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01 ();
  _10 = (int) Unit;
  SwNormalQueueIndex = Adc_aUnitStatus[_10].SwNormalQueueIndex;
  _11 = (int) Unit;
  _12 = Adc_aUnitStatus[_11].SwNormalQueue[0];
  if (Group == _12)
    goto <bb 6>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  if (SwNormalQueueIndex == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 6> :
  _13 = (int) Unit;
  _14 = Adc_aUnitStatus[_13].SwNormalQueueIndex;
  if (_14 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _15 = (int) Unit;
  Adc_aUnitStatus[_15].SwNormalQueue[0] = Group;
  _16 = (int) Unit;
  _17 = Adc_aUnitStatus[_16].SwNormalQueueIndex;
  _18 = _17;
  _19 = _18 + 1;
  Adc_aUnitStatus[_16].SwNormalQueueIndex = _19;

  <bb 8> :
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01 ();
  Adc_Ipw_StartNormalConversion (Unit, u32CoreId);
  goto <bb 10>; [INV]

  <bb 9> :
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01 ();

  <bb 10> :
  return;

}


Adc_RemoveFromQueue (const Adc_HwUnitType Unit, const Adc_QueueIndexType CurQueueIndex)
{
  Adc_QueueIndexType CurrentIndex;
  Adc_QueueIndexType PositionIndex;

  <bb 2> :
  PositionIndex = 0;
  CurrentIndex = 0;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00 ();
  _1 = (int) Unit;
  CurrentIndex = Adc_aUnitStatus[_1].SwNormalQueueIndex;
  if (CurrentIndex <= 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _2 = (int) Unit;
  Adc_aUnitStatus[_2].SwNormalQueueIndex = 0;
  goto <bb 8>; [INV]

  <bb 4> :
  PositionIndex = CurQueueIndex + 1;
  goto <bb 6>; [INV]

  <bb 5> :
  _3 = (int) Unit;
  _4 = (int) PositionIndex;
  _5 = (int) Unit;
  _6 = (unsigned int) PositionIndex;
  _7 = _6 + 4294967295;
  _8 = Adc_aUnitStatus[_3].SwNormalQueue[_4];
  Adc_aUnitStatus[_5].SwNormalQueue[_7] = _8;
  PositionIndex.0_9 = PositionIndex;
  PositionIndex = PositionIndex.0_9 + 1;

  <bb 6> :
  if (PositionIndex < CurrentIndex)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _10 = (int) Unit;
  _11 = Adc_aUnitStatus[_10].SwNormalQueueIndex;
  _12 = _11;
  _13 = _12 + 65535;
  Adc_aUnitStatus[_10].SwNormalQueueIndex = _13;

  <bb 8> :
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00 ();
  return;

}


Adc_CheckCurrentCoreId (const struct Adc_ConfigType * pCfgPtr, uint32 u32CoreId)
{
  Std_ReturnType ValidCoreId;
  uint8 Index;
  Std_ReturnType D.7147;

  <bb 2> :
  Index = 0;
  ValidCoreId = 1;
  _1 = pCfgPtr->u32CoreId;
  if (u32CoreId == _1)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  Index = 0;
  goto <bb 7>; [INV]

  <bb 4> :
  _2 = pCfgPtr->pAssignmentPartition;
  _3 = (sizetype) Index;
  _4 = _2 + _3;
  _5 = *_4;
  _6 = (long unsigned int) _5;
  if (u32CoreId == _6)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  ValidCoreId = 0;
  goto <bb 8>; [INV]

  <bb 6> :
  Index.8_7 = Index;
  Index = Index.8_7 + 1;

  <bb 7> :
  _8 = pCfgPtr->AssignedPartitionCount;
  if (Index < _8)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  D.7147 = ValidCoreId;

  <bb 9> :
<L7>:
  return D.7147;

}


Adc_InitUnitStatus (uint32 u32CoreId)
{
  Adc_QueueIndexType QueueIdx;
  Adc_HwUnitType LogicalHwUnitId;

  <bb 2> :
  LogicalHwUnitId = 0;
  QueueIdx = 0;
  LogicalHwUnitId = 0;
  goto <bb 9>; [INV]

  <bb 3> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pAdcIpwConfig;
  _3 = (int) LogicalHwUnitId;
  _4 = _2->Mapping.au8Adc_HwUnit[_3];
  if (_4 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  _5 = (int) LogicalHwUnitId;
  Adc_aUnitStatus[_5].SwNormalQueueIndex = 0;
  QueueIdx = 0;
  goto <bb 6>; [INV]

  <bb 5> :
  _6 = (int) LogicalHwUnitId;
  _7 = (int) QueueIdx;
  Adc_aUnitStatus[_6].SwNormalQueue[_7] = 0;
  QueueIdx.9_8 = QueueIdx;
  QueueIdx = QueueIdx.9_8 + 1;

  <bb 6> :
  if (QueueIdx <= 9)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _9 = (int) LogicalHwUnitId;
  Adc_aUnitStatus[_9].OngoingHwGroup = 65535;
  _10 = (int) LogicalHwUnitId;
  Adc_aUnitStatus[_10].u8Sc1Used = 0;

  <bb 8> :
  LogicalHwUnitId.10_11 = LogicalHwUnitId;
  LogicalHwUnitId = LogicalHwUnitId.10_11 + 1;

  <bb 9> :
  if (LogicalHwUnitId <= 1)
    goto <bb 3>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  return;

}


Adc_InitGroupsStatus (uint32 u32CoreId)
{
  Adc_GroupType GroupId;
  Adc_GroupType u16GroupCnt;

  <bb 2> :
  u16GroupCnt = 0;
  GroupId = 0;
  u16GroupCnt = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroups;
  _3 = (unsigned int) u16GroupCnt;
  _4 = _3 * 68;
  _5 = _2 + _4;
  GroupId = _5->GroupId;
  _6 = (int) GroupId;
  Adc_aGroupStatus[_6].eConversion = 0;
  _7 = (int) GroupId;
  Adc_aGroupStatus[_7].eAlreadyConverted = 0;
  _8 = (int) GroupId;
  Adc_aGroupStatus[_8].ResultIndex = 0;
  _9 = (int) GroupId;
  Adc_aGroupStatus[_9].CurrentChannel = 0;
  _10 = (int) GroupId;
  Adc_aGroupStatus[_10].bLimitCheckFailed = 0;
  _11 = (int) GroupId;
  Adc_aGroupStatus[_11].eHwTriggering = 0;
  _12 = (int) GroupId;
  Adc_aGroupStatus[_12].eNotification = 0;
  _13 = Adc_pCfgPtr[u32CoreId];
  _14 = _13->pGroups;
  _15 = (unsigned int) u16GroupCnt;
  _16 = _15 * 68;
  _17 = _14 + _16;
  _18 = (int) GroupId;
  _19 = _17->pAssignment;
  Adc_aRuntimeGroupChannel[_18].pChannel = _19;
  _20 = Adc_pCfgPtr[u32CoreId];
  _21 = _20->pGroups;
  _22 = (unsigned int) u16GroupCnt;
  _23 = _22 * 68;
  _24 = _21 + _23;
  _25 = (int) GroupId;
  _26 = _24->AssignedChannelCount;
  Adc_aRuntimeGroupChannel[_25].ChannelCount = _26;
  _27 = (int) GroupId;
  Adc_aRuntimeGroupChannel[_27].bRuntimeUpdated = 0;
  _28 = (int) GroupId;
  Adc_aRuntimeGroupChannel[_28].bAdcRuntimeGroupLimitcheck = 0;
  _29 = Adc_pCfgPtr[u32CoreId];
  _30 = _29->pGroups;
  _31 = (unsigned int) u16GroupCnt;
  _32 = _31 * 68;
  _33 = _30 + _32;
  _34 = _33->pAdcIpwGroupConfig;
  _35 = (int) GroupId;
  _36 = _34->pDelay;
  Adc_aRuntimeGroupChannel[_35].pu16Delays = _36;
  _37 = (int) GroupId;
  Adc_aRuntimeGroupChannel[_37].u32Mask = 4294967295;
  u16GroupCnt.11_38 = u16GroupCnt;
  u16GroupCnt = u16GroupCnt.11_38 + 1;

  <bb 4> :
  _39 = Adc_pCfgPtr[u32CoreId];
  _40 = _39->GroupCount;
  if (u16GroupCnt < _40)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  return;

}


Adc_NotifyCapablity (uint8 u8ServiceId, Adc_GroupType Group, uint32 u32CoreId)
{
  unsigned int D.7418;
  unsigned int D.7417;
  Std_ReturnType ValidCapability;
  Adc_GroupType GroupIndex;
  Std_ReturnType D.7415;

  <bb 2> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  ValidCapability = 0;
  _6 = (int) u8ServiceId;
  D.7417 = (unsigned int) _6;
  D.7418 = D.7417 + 4294967289;
  if (D.7418 <= 1)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
<L0>:
  _7 = Adc_pCfgPtr[u32CoreId];
  _8 = _7->pGroups;
  _9 = (unsigned int) GroupIndex;
  _10 = _9 * 68;
  _11 = _8 + _10;
  _12 = _11->Notification;
  if (_12 == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  ValidCapability = 1;
  Adc_ReportDetError (u8ServiceId, 24);

  <bb 5> :
  goto <bb 7>; [INV]

  <bb 6> :
<L4>:

  <bb 7> :
  D.7415 = ValidCapability;

  <bb 8> :
<L6>:
  return D.7415;

}


Adc_ValidateCallAndUnit (uint8 u8ServiceId, Adc_HwUnitType Unit, uint32 u32CoreId)
{
  Std_ReturnType ValidCoreId;
  Std_ReturnType ValidCallAndUnit;
  Std_ReturnType D.7487;

  <bb 2> :
  ValidCallAndUnit = 1;
  _1 = Adc_pCfgPtr[u32CoreId];
  if (_1 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  Adc_ReportDetError (u8ServiceId, 10);
  goto <bb 11>; [INV]

  <bb 4> :
  if (Unit != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  Adc_ReportDetError (u8ServiceId, 38);
  goto <bb 11>; [INV]

  <bb 6> :
  _2 = Adc_pCfgPtr[u32CoreId];
  ValidCoreId = Adc_CheckCurrentCoreId (_2, u32CoreId);
  if (ValidCoreId == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _3 = Adc_pCfgPtr[u32CoreId];
  _4 = _3->pAdcIpwConfig;
  _5 = (int) Unit;
  _6 = _4->Mapping.au8Adc_HwUnit[_5];
  if (_6 == 1)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  ValidCallAndUnit = 0;
  goto <bb 11>; [INV]

  <bb 9> :
  Adc_ReportDetError (u8ServiceId, 14);
  goto <bb 11>; [INV]

  <bb 10> :
  Adc_ReportDetError (u8ServiceId, 14);

  <bb 11> :
  D.7487 = ValidCallAndUnit;

  <bb 12> :
<L12>:
  return D.7487;

}


Adc_ValidateCallAndGroup (uint8 u8ServiceId, Adc_GroupType Group, uint32 u32CoreId)
{
  Adc_GroupType GroupIndex;
  Std_ReturnType ValidCoreId;
  Std_ReturnType ValidCallAndGroup;
  Std_ReturnType D.7176;

  <bb 2> :
  ValidCallAndGroup = 1;
  ValidCoreId = 1;
  GroupIndex = 0;
  _1 = Adc_pCfgPtr[u32CoreId];
  if (_1 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  Adc_ReportDetError (u8ServiceId, 10);
  goto <bb 11>; [INV]

  <bb 4> :
  _2 = Adc_pCfgPtr[u32CoreId];
  ValidCoreId = Adc_CheckCurrentCoreId (_2, u32CoreId);
  if (ValidCoreId == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 5> :
  if (Group > 6)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  Adc_ReportDetError (u8ServiceId, 21);
  goto <bb 11>; [INV]

  <bb 7> :
  _3 = Adc_pCfgPtr[u32CoreId];
  _4 = _3->pGroupIdToIndexMap;
  _5 = (unsigned int) Group;
  _6 = _5 * 2;
  _7 = _4 + _6;
  GroupIndex = *_7;
  _8 = Adc_pCfgPtr[u32CoreId];
  _9 = _8->pGroups;
  _10 = (unsigned int) GroupIndex;
  _11 = _10 * 68;
  _12 = _9 + _11;
  _13 = _12->GroupId;
  if (Group != _13)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  Adc_ReportDetError (u8ServiceId, 14);
  goto <bb 11>; [INV]

  <bb 9> :
  ValidCallAndGroup = 0;
  goto <bb 11>; [INV]

  <bb 10> :
  Adc_ReportDetError (u8ServiceId, 14);

  <bb 11> :
  D.7176 = ValidCallAndGroup;

  <bb 12> :
<L12>:
  return D.7176;

}


Adc_ValidateStateNotIdle (uint8 u8ServiceId, Adc_GroupType Group, uint32 u32CoreId)
{
  Std_ReturnType ValidState;
  Std_ReturnType D.7311;

  <bb 2> :
  ValidState = 0;
  _1 = (int) u8ServiceId;
  switch (_1) <default: <L15> [INV], case 3: <L5> [INV], case 4: <L0> [INV], case 6: <L9> [INV], case 11: <L12> [INV]>

  <bb 3> :
<L0>:
  _2 = (int) Group;
  _3 = Adc_aGroupStatus[_2].eConversion;
  if (_3 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _4 = (int) Group;
  _5 = Adc_aGroupStatus[_4].eAlreadyConverted;
  if (_5 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  Adc_ReportDetRuntimeError (u8ServiceId, 12);
  ValidState = 1;

  <bb 6> :
  goto <bb 17>; [INV]

  <bb 7> :
<L5>:
  _6 = (int) Group;
  _7 = Adc_aGroupStatus[_6].eConversion;
  if (_7 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  Adc_ReportDetRuntimeError (u8ServiceId, 12);
  ValidState = 1;

  <bb 9> :
  goto <bb 17>; [INV]

  <bb 10> :
<L9>:
  _8 = (int) Group;
  _9 = Adc_aGroupStatus[_8].eHwTriggering;
  if (_9 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  Adc_ReportDetRuntimeError (u8ServiceId, 12);
  ValidState = 1;

  <bb 12> :
  goto <bb 17>; [INV]

  <bb 13> :
<L12>:
  _10 = (int) Group;
  _11 = Adc_aGroupStatus[_10].eConversion;
  if (_11 == 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  Adc_ReportDetRuntimeError (u8ServiceId, 12);
  ValidState = 1;

  <bb 15> :
  goto <bb 17>; [INV]

  <bb 16> :
<L15>:

  <bb 17> :
  D.7311 = ValidState;

  <bb 18> :
<L17>:
  return D.7311;

}


Adc_ValidateStateEnableHwTriggNotBusy (Adc_GroupType Group, uint32 u32CoreId)
{
  Std_ReturnType ValidState;
  Std_ReturnType D.7391;

  <bb 2> :
  ValidState = 1;
  ValidState = Adc_ValidateNotBusyEnableHwTrig (5, Group, u32CoreId);
  D.7391 = ValidState;

  <bb 3> :
<L0>:
  return D.7391;

}


Adc_ValidateStateStartGroupConvNotBusy (Adc_GroupType Group, uint32 u32CoreId)
{
  Adc_GroupConvType eTypeHwGroup;
  Adc_GroupType HwGroupId;
  Adc_GroupType OngoingHwGroupId;
  Adc_GroupConvType eTypeSwGroup;
  Adc_HwUnitType LogicalHwUnitId;
  boolean bImplicitly;
  Std_ReturnType ValidState;
  Adc_GroupType GroupIndex;
  Std_ReturnType D.7240;

  <bb 2> :
  ValidState = 0;
  bImplicitly = 0;
  LogicalHwUnitId = 0;
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  _6 = Adc_pCfgPtr[u32CoreId];
  _7 = _6->pGroups;
  _8 = (unsigned int) GroupIndex;
  _9 = _8 * 68;
  _10 = _7 + _9;
  _11 = _10->eMode;
  if (_11 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  _12 = Adc_pCfgPtr[u32CoreId];
  _13 = _12->pGroups;
  _14 = (unsigned int) GroupIndex;
  _15 = _14 * 68;
  _16 = _13 + _15;
  _17 = _16->eMode;
  if (_17 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  _18 = Adc_pCfgPtr[u32CoreId];
  _19 = _18->pGroups;
  _20 = (unsigned int) GroupIndex;
  _21 = _20 * 68;
  _22 = _19 + _21;
  _23 = _22->eAccessMode;
  if (_23 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _24 = Adc_pCfgPtr[u32CoreId];
  _25 = _24->pGroups;
  _26 = (unsigned int) GroupIndex;
  _27 = _26 * 68;
  _28 = _25 + _27;
  _29 = _28->eBufferMode;
  if (_29 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  bImplicitly = 1;

  <bb 7> :
  _30 = Adc_pCfgPtr[u32CoreId];
  _31 = _30->pGroups;
  _32 = (unsigned int) GroupIndex;
  _33 = _32 * 68;
  _34 = _31 + _33;
  LogicalHwUnitId = _34->AdcLogicalUnitId;
  _35 = (int) LogicalHwUnitId;
  OngoingHwGroupId = Adc_aUnitStatus[_35].OngoingHwGroup;
  if (OngoingHwGroupId != 65535)
    goto <bb 8>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 8> :
  _36 = Adc_pCfgPtr[u32CoreId];
  _37 = _36->pGroups;
  _38 = (unsigned int) GroupIndex;
  _39 = _38 * 68;
  _40 = _37 + _39;
  eTypeSwGroup = _40->eType;
  _41 = Adc_pCfgPtr[u32CoreId];
  _42 = _41->pGroupIdToIndexMap;
  _43 = (unsigned int) OngoingHwGroupId;
  _44 = _43 * 2;
  _45 = _42 + _44;
  HwGroupId = *_45;
  _46 = Adc_pCfgPtr[u32CoreId];
  _47 = _46->pGroups;
  _48 = (unsigned int) HwGroupId;
  _49 = _48 * 68;
  _50 = _47 + _49;
  eTypeHwGroup = _50->eType;
  if (eTypeSwGroup == 1)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  if (eTypeHwGroup == 1)
    goto <bb 12>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  if (eTypeSwGroup == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 11> :
  if (eTypeHwGroup == 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  ValidState = 1;

  <bb 13> :
  if (ValidState == 1)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  Adc_ReportDetRuntimeError (2, 11);
  goto <bb 16>; [INV]

  <bb 15> :
  ValidState = Adc_ValidateNotBusyNoPrio (Group, bImplicitly, u32CoreId);

  <bb 16> :
  D.7240 = ValidState;

  <bb 17> :
<L15>:
  return D.7240;

}


Adc_ValidateSetupBufferNotBusy (Adc_GroupType Group)
{
  Std_ReturnType ValidState;
  Std_ReturnType D.7185;

  <bb 2> :
  ValidState = 1;
  _1 = (int) Group;
  _2 = Adc_aGroupStatus[_1].eConversion;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  Adc_ReportDetRuntimeError (12, 11);
  goto <bb 5>; [INV]

  <bb 4> :
  ValidState = 0;

  <bb 5> :
  D.7185 = ValidState;

  <bb 6> :
<L3>:
  return D.7185;

}


Adc_ValidateDeInitNotBusy (uint32 u32CoreId)
{
  Adc_HwUnitType LogicalHwUnitId;
  Std_ReturnType ValidState;
  Std_ReturnType ErrorFound;
  Std_ReturnType D.7206;

  <bb 2> :
  ErrorFound = 0;
  ValidState = 1;
  LogicalHwUnitId = 0;
  LogicalHwUnitId = 0;
  goto <bb 7>; [INV]

  <bb 3> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pAdcIpwConfig;
  _3 = (int) LogicalHwUnitId;
  _4 = _2->Mapping.au8Adc_HwUnit[_3];
  if (_4 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  ErrorFound = Adc_ValidateNotBusyNoQueue (LogicalHwUnitId, 1);
  if (ErrorFound == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  goto <bb 8>; [INV]

  <bb 6> :
  LogicalHwUnitId.23_5 = LogicalHwUnitId;
  LogicalHwUnitId = LogicalHwUnitId.23_5 + 1;

  <bb 7> :
  if (LogicalHwUnitId <= 1)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  if (ErrorFound == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _6 = Adc_ValidateCheckGroupNotConversion (1, u32CoreId);
  if (_6 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  ValidState = 0;

  <bb 11> :
  D.7206 = ValidState;

  <bb 12> :
<L11>:
  return D.7206;

}


Adc_ValidateCheckGroupNotConversion (uint8 u8ServiceId, uint32 u32CoreId)
{
  Std_ReturnType ErrorFound;
  Adc_GroupType GroupId;
  Adc_GroupType GroupIter;
  Adc_StatusType eConversion;
  Std_ReturnType D.7217;

  <bb 2> :
  ErrorFound = 0;
  GroupIter = 0;
  goto <bb 7>; [INV]

  <bb 3> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroups;
  _3 = (unsigned int) GroupIter;
  _4 = _3 * 68;
  _5 = _2 + _4;
  GroupId = _5->GroupId;
  _6 = (int) GroupId;
  eConversion = Adc_aGroupStatus[_6].eConversion;
  if (eConversion != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  if (eConversion != 3)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  Adc_ReportDetRuntimeError (u8ServiceId, 11);
  ErrorFound = 1;

  <bb 6> :
  GroupIter.24_7 = GroupIter;
  GroupIter = GroupIter.24_7 + 1;

  <bb 7> :
  _8 = Adc_pCfgPtr[u32CoreId];
  _9 = _8->GroupCount;
  if (GroupIter < _9)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  D.7217 = ErrorFound;

  <bb 9> :
<L7>:
  return D.7217;

}


Adc_ValidateNotBusyNoPrio (Adc_GroupType Group, boolean bImplicitly, uint32 u32CoreId)
{
  Adc_StatusType eConversion;
  Std_ReturnType ValidState;
  Std_ReturnType D.7251;

  <bb 2> :
  ValidState = 1;
  _1 = (int) Group;
  eConversion = Adc_aGroupStatus[_1].eConversion;
  _2 = ~bImplicitly;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  if (eConversion != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  Adc_ReportDetRuntimeError (2, 11);
  goto <bb 10>; [INV]

  <bb 5> :
  if (bImplicitly != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 6> :
  if (eConversion != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  if (eConversion != 3)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  Adc_ReportDetRuntimeError (2, 11);
  goto <bb 10>; [INV]

  <bb 9> :
  ValidState = 0;

  <bb 10> :
  D.7251 = ValidState;

  <bb 11> :
<L9>:
  return D.7251;

}


Adc_ValidateNotBusyEnableHwTrig (uint8 u8ServiceId, Adc_GroupType Group, uint32 u32CoreId)
{
  Adc_GroupType OngoingHwGroupId;
  Adc_GroupConvType eGroupType;
  Adc_QueueIndexType NoGroupsInSwNormalQueue;
  Adc_HwUnitType LogicalHwUnitId;
  Std_ReturnType ValidState;
  Adc_GroupType GroupIndex;
  Std_ReturnType D.7401;

  <bb 2> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  ValidState = 1;
  _6 = Adc_pCfgPtr[u32CoreId];
  _7 = _6->pGroups;
  _8 = (unsigned int) GroupIndex;
  _9 = _8 * 68;
  _10 = _7 + _9;
  LogicalHwUnitId = _10->AdcLogicalUnitId;
  _11 = (int) LogicalHwUnitId;
  NoGroupsInSwNormalQueue = Adc_aUnitStatus[_11].SwNormalQueueIndex;
  _12 = Adc_pCfgPtr[u32CoreId];
  _13 = _12->pGroups;
  _14 = (unsigned int) GroupIndex;
  _15 = _14 * 68;
  _16 = _13 + _15;
  eGroupType = _16->eType;
  _17 = (int) LogicalHwUnitId;
  OngoingHwGroupId = Adc_aUnitStatus[_17].OngoingHwGroup;
  _18 = (int) u8ServiceId;
  if (_18 == 5)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
<L0>:
  if (OngoingHwGroupId == 65535)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  if (eGroupType == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (NoGroupsInSwNormalQueue == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ValidState = 0;

  <bb 7> :
  goto <bb 9>; [INV]

  <bb 8> :
<L7>:

  <bb 9> :
  if (ValidState == 1)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  Adc_ReportDetRuntimeError (u8ServiceId, 11);

  <bb 11> :
  D.7401 = ValidState;

  <bb 12> :
<L11>:
  return D.7401;

}


Adc_ValidateNotBusyNoQueue (Adc_HwUnitType Unit, uint8 u8ServiceId)
{
  Adc_GroupType NoGroupsInSwNormalQueue;
  Adc_GroupType OngoingHwGroupId;
  Std_ReturnType ErrorFound;
  Std_ReturnType D.7211;

  <bb 2> :
  ErrorFound = 0;
  _1 = (int) Unit;
  NoGroupsInSwNormalQueue = Adc_aUnitStatus[_1].SwNormalQueueIndex;
  _2 = (int) Unit;
  OngoingHwGroupId = Adc_aUnitStatus[_2].OngoingHwGroup;
  if (NoGroupsInSwNormalQueue != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (OngoingHwGroupId != 65535)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  Adc_ReportDetRuntimeError (u8ServiceId, 11);
  ErrorFound = 1;

  <bb 5> :
  D.7211 = ErrorFound;

  <bb 6> :
<L3>:
  return D.7211;

}


Adc_EndValidateGloballCall (Std_ReturnType ValidCall, uint8 u8ServiceId, uint32 u32CoreId)
{
  <bb 2> :
  if (ValidCall == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  if (u8ServiceId == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  Adc_eGlobalState[u32CoreId] = 0;
  goto <bb 6>; [INV]

  <bb 5> :
  Adc_eGlobalState[u32CoreId] = 2;

  <bb 6> :
  return;

}


Adc_ValidateExtraParams (uint8 u8ServiceId, uint32 u32ErrorIdList, Adc_GroupType Group, uint32 u32CoreId)
{
  struct Adc_ValidationResultType ValidationStatus;
  Std_ReturnType D.7269;

  <bb 2> :
  ValidationStatus.bEndValidations = 0;
  ValidationStatus.ValidParams = 0;
  _1 = u32ErrorIdList & 1;
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _2 = ValidationStatus.bEndValidations;
  _3 = ~_2;
  if (_3 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  Adc_ValidateBufferUninit (&ValidationStatus, u8ServiceId, Group, u32CoreId);

  <bb 5> :
  _4 = u32ErrorIdList & 2;
  if (_4 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _5 = ValidationStatus.bEndValidations;
  _6 = ~_5;
  if (_6 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  Adc_ValidateTriggerSrc (&ValidationStatus, u8ServiceId, Group, u32CoreId);

  <bb 8> :
  _7 = u32ErrorIdList & 4;
  if (_7 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _8 = ValidationStatus.bEndValidations;
  _9 = ~_8;
  if (_9 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  Adc_ValidateQueueNotFull (&ValidationStatus, u8ServiceId, Group, u32CoreId);

  <bb 11> :
  _10 = u32ErrorIdList & 8;
  if (_10 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 12> :
  _11 = ValidationStatus.bEndValidations;
  _12 = ~_11;
  if (_12 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  Adc_ValidateConvMode (&ValidationStatus, u8ServiceId, Group, u32CoreId);

  <bb 14> :
  D.7269 = ValidationStatus.ValidParams;
  ValidationStatus = {CLOBBER};

  <bb 15> :
<L17>:
  return D.7269;

}


Adc_ValidateConvMode (struct Adc_ValidationResultType * pReturnValue, uint8 u8ServiceId, Adc_GroupType Group, uint32 u32CoreId)
{
  unsigned int D.7285;
  unsigned int D.7284;
  Adc_GroupType GroupIndex;

  <bb 2> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  _6 = (int) u8ServiceId;
  D.7284 = (unsigned int) _6;
  D.7285 = D.7284 + 4294967291;
  if (D.7285 <= 1)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
<L0>:
  _7 = Adc_pCfgPtr[u32CoreId];
  _8 = _7->pGroups;
  _9 = (unsigned int) GroupIndex;
  _10 = _9 * 68;
  _11 = _8 + _10;
  _12 = _11->eMode;
  if (_12 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  Adc_ReportValidationError (pReturnValue, u8ServiceId, 22);

  <bb 5> :
  goto <bb 7>; [INV]

  <bb 6> :
<L4>:

  <bb 7> :
  return;

}


Adc_ValidateQueueNotFull (struct Adc_ValidationResultType * pReturnValue, uint8 u8ServiceId, Adc_GroupType Group, uint32 u32CoreId)
{
  Adc_HwUnitType LogicalHwUnitId;
  Adc_GroupType GroupIndex;

  <bb 2> :
  LogicalHwUnitId = 0;
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  _6 = Adc_pCfgPtr[u32CoreId];
  _7 = _6->pGroups;
  _8 = (unsigned int) GroupIndex;
  _9 = _8 * 68;
  _10 = _7 + _9;
  LogicalHwUnitId = _10->AdcLogicalUnitId;
  _11 = (int) u8ServiceId;
  if (_11 == 2)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
<L0>:
  _12 = Adc_pCfgPtr[u32CoreId];
  _13 = _12->pGroups;
  _14 = (unsigned int) GroupIndex;
  _15 = _14 * 68;
  _16 = _13 + _15;
  _17 = _16->eType;
  if (_17 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _18 = (int) LogicalHwUnitId;
  _19 = Adc_aUnitStatus[_18].SwNormalQueueIndex;
  if (_19 > 9)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  Adc_ReportValidationError (pReturnValue, u8ServiceId, 32);

  <bb 6> :
  goto <bb 8>; [INV]

  <bb 7> :
<L5>:

  <bb 8> :
  return;

}


Adc_ValidateTriggerSrc (struct Adc_ValidationResultType * pReturnValue, uint8 u8ServiceId, Adc_GroupType Group, uint32 u32CoreId)
{
  Adc_GroupType GroupIndex;

  <bb 2> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  _6 = (int) u8ServiceId;
  switch (_6) <default: <L8> [INV], case 2 ... 3: <L0> [INV], case 5 ... 6: <L4> [INV]>

  <bb 3> :
<L0>:
  _7 = Adc_pCfgPtr[u32CoreId];
  _8 = _7->pGroups;
  _9 = (unsigned int) GroupIndex;
  _10 = _9 * 68;
  _11 = _8 + _10;
  _12 = _11->eTriggerSource;
  if (_12 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  Adc_ReportValidationError (pReturnValue, u8ServiceId, 23);

  <bb 5> :
  goto <bb 10>; [INV]

  <bb 6> :
<L4>:
  _13 = Adc_pCfgPtr[u32CoreId];
  _14 = _13->pGroups;
  _15 = (unsigned int) GroupIndex;
  _16 = _15 * 68;
  _17 = _14 + _16;
  _18 = _17->eTriggerSource;
  if (_18 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  Adc_ReportValidationError (pReturnValue, u8ServiceId, 23);

  <bb 8> :
  goto <bb 10>; [INV]

  <bb 9> :
<L8>:

  <bb 10> :
  return;

}


Adc_ValidateBufferUninit (struct Adc_ValidationResultType * pReturnValue, uint8 u8ServiceId, Adc_GroupType Group, uint32 u32CoreId)
{
  Adc_GroupType GroupIndex;

  <bb 2> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  _6 = (int) u8ServiceId;
  switch (_6) <default: <L4> [INV], case 2: <L0> [INV], case 5: <L0> [INV]>

  <bb 3> :
<L0>:
  _7 = Adc_pCfgPtr[u32CoreId];
  _8 = _7->pGroups;
  _9 = (unsigned int) GroupIndex;
  _10 = _9 * 68;
  _11 = _8 + _10;
  _12 = _11->pResultsBufferPtr;
  _13 = (unsigned int) Group;
  _14 = _13 * 4;
  _15 = _12 + _14;
  _16 = *_15;
  if (_16 == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  Adc_ReportValidationError (pReturnValue, u8ServiceId, 25);

  <bb 5> :
  goto <bb 7>; [INV]

  <bb 6> :
<L4>:

  <bb 7> :
  return;

}


Adc_ValidatePtr (uint8 u8ServiceId, const void * pPtrVal)
{
  Std_ReturnType ValidPtr;
  Std_ReturnType D.7180;

  <bb 2> :
  ValidPtr = 0;
  if (pPtrVal == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ValidPtr = 1;
  Adc_ReportDetError (u8ServiceId, 20);

  <bb 4> :
  D.7180 = ValidPtr;

  <bb 5> :
<L2>:
  return D.7180;

}


Adc_ValidatePtrInit (const struct Adc_ConfigType * pConfigPtr)
{
  Std_ReturnType ValidPtr;
  Std_ReturnType D.7141;

  <bb 2> :
  ValidPtr = 0;
  if (pConfigPtr == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ValidPtr = 1;
  Adc_ReportDetError (0, 20);

  <bb 4> :
  D.7141 = ValidPtr;

  <bb 5> :
<L2>:
  return D.7141;

}


Adc_ValidateGloballCall (uint8 u8ServiceId, uint32 u32CoreId)
{
  Std_ReturnType ValidState;
  Std_ReturnType D.7137;

  <bb 2> :
  ValidState = 1;
  _1 = Adc_eGlobalState[u32CoreId];
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  if (u8ServiceId == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  ValidState = 0;
  goto <bb 9>; [INV]

  <bb 5> :
  Adc_ReportDetError (u8ServiceId, 10);
  goto <bb 9>; [INV]

  <bb 6> :
  if (u8ServiceId == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  Adc_ReportDetError (u8ServiceId, 13);
  goto <bb 9>; [INV]

  <bb 8> :
  ValidState = 0;

  <bb 9> :
  D.7137 = ValidState;

  <bb 10> :
<L9>:
  return D.7137;

}


Adc_ReportValidationError (struct Adc_ValidationResultType * pResult, uint8 u8ServiceId, uint8 u8ErrorId)
{
  <bb 2> :
  pResult->bEndValidations = 1;
  pResult->ValidParams = 1;
  Adc_ReportDetError (u8ServiceId, u8ErrorId);
  return;

}


Adc_ReportDetRuntimeError (uint8 u8ServiceId, uint8 u8ErrorId)
{
  <bb 2> :
  Det_ReportRuntimeError (123, 0, u8ServiceId, u8ErrorId);
  return;

}


Adc_ReportDetError (uint8 u8ServiceId, uint8 u8ErrorId)
{
  <bb 2> :
  Det_ReportError (123, 0, u8ServiceId, u8ErrorId);
  return;

}


