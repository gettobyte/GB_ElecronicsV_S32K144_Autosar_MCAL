Adc_SetChannel (const Adc_GroupType Group, const Adc_GroupDefType * Channel, const uint16 * Delays, const uint32 ChannelUpdateMask, const Adc_ChannelIndexType NumberOfChannel)
{
  Adc_GroupType GroupIndex;
  Adc_HwUnitType LogicalHwUnitId;
  volatile uint32 u32CoreId;

  <bb 2> :
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  LogicalHwUnitId = 0;
  GroupIndex = 0;
  _2 = (int) Group;
  Adc_aRuntimeGroupChannel[_2].pChannel = Channel;
  _3 = (int) Group;
  Adc_aRuntimeGroupChannel[_3].ChannelCount = NumberOfChannel;
  _4 = (int) Group;
  Adc_aRuntimeGroupChannel[_4].bRuntimeUpdated = 1;
  u32CoreId.50_5 = u32CoreId;
  _6 = Adc_pCfgPtr[u32CoreId.50_5];
  _7 = _6->pGroupIdToIndexMap;
  _8 = (unsigned int) Group;
  _9 = _8 * 2;
  _10 = _7 + _9;
  GroupIndex = *_10;
  u32CoreId.51_11 = u32CoreId;
  _12 = Adc_pCfgPtr[u32CoreId.51_11];
  _13 = _12->pGroups;
  _14 = (unsigned int) GroupIndex;
  _15 = _14 * 60;
  _16 = _13 + _15;
  LogicalHwUnitId = _16->AdcLogicalUnitId;
  u32CoreId.52_17 = u32CoreId;
  _18 = Adc_pCfgPtr[u32CoreId.52_17];
  _19 = _18->pAdcIpwConfig;
  _20 = (int) LogicalHwUnitId;
  _21 = _19->ChannelLimitCheckingConfigs[_20];
  _22 = *Channel;
  _23 = (unsigned int) _22;
  _24 = _23 * 12;
  _25 = _21 + _24;
  _26 = (int) Group;
  _27 = _25->bChannelLimitCheckEnabled;
  Adc_aRuntimeGroupChannel[_26].bAdcRuntimeGroupLimitcheck = _27;
  _28 = (int) Group;
  Adc_aRuntimeGroupChannel[_28].pu16Delays = Delays;
  if (NumberOfChannel <= 16)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _29 = (int) Group;
  Adc_aRuntimeGroupChannel[_29].u32Mask = ChannelUpdateMask;
  goto <bb 5>; [INV]

  <bb 4> :
  _30 = (int) Group;
  Adc_aRuntimeGroupChannel[_30].u32Mask = 4294967295;

  <bb 5> :
  return;

}


Adc_SetClockMode (Adc_SelectPrescalerType Prescaler)
{
  Std_ReturnType ErrorFound;
  Adc_HwUnitType LogicalHwUnitId;
  Std_ReturnType Ret;
  volatile uint32 u32CoreId;
  Std_ReturnType D.7005;

  <bb 2> :
  Ret = 1;
  ErrorFound = 0;
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  LogicalHwUnitId = 0;
  goto <bb 7>; [INV]

  <bb 3> :
  u32CoreId.46_2 = u32CoreId;
  _3 = Adc_pCfgPtr[u32CoreId.46_2];
  _4 = _3->pAdcIpwConfig;
  _5 = (int) LogicalHwUnitId;
  _6 = _4->Mapping.au8Adc_HwUnit[_5];
  if (_6 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  ErrorFound = Adc_ValidateNotBusyNoQueue (LogicalHwUnitId, 37);
  if (ErrorFound == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  goto <bb 8>; [INV]

  <bb 6> :
  LogicalHwUnitId.47_7 = LogicalHwUnitId;
  LogicalHwUnitId = LogicalHwUnitId.47_7 + 1;

  <bb 7> :
  if (LogicalHwUnitId <= 1)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  if (ErrorFound == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  u32CoreId.48_8 = u32CoreId;
  _9 = Adc_ValidateCheckGroupNotConversion (37, u32CoreId.48_8);
  if (_9 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  u32CoreId.49_10 = u32CoreId;
  Ret = Adc_Ipw_SetClockMode (Prescaler, u32CoreId.49_10);

  <bb 11> :
  D.7005 = Ret;

  <bb 12> :
<L11>:
  return D.7005;

}


Adc_Calibrate (Adc_HwUnitType Unit, struct Adc_CalibrationStatusType * pStatus)
{
  boolean isCalibrateCalled;
  volatile uint32 u32CoreId;

  <bb 2> :
  isCalibrateCalled = 0;
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  pStatus->Adc_UnitSelfTestStatus = 1;
  _2 = Adc_ValidateNotBusyNoQueue (Unit, 41);
  if (_2 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  u32CoreId.44_3 = u32CoreId;
  _4 = Adc_ValidateCheckGroupNotConversion (41, u32CoreId.44_3);
  if (_4 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  u32CoreId.45_5 = u32CoreId;
  Adc_Ipw_Calibrate (Unit, pStatus, u32CoreId.45_5);
  isCalibrateCalled = 1;

  <bb 5> :
  if (isCalibrateCalled != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _6 = pStatus->Adc_UnitSelfTestStatus;
  if (_6 == 1)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  Adc_ReportDetRuntimeError (41, 43);

  <bb 8> :
  return;

}


Adc_ReadRawData (Adc_HwUnitType Unit, const Adc_ChannelType * const ChansArray, uint8 NumItems, Adc_ValueGroupType * const DataBufferPtr)
{
  Std_ReturnType Status;
  const uint32 u32CoreId;
  uint8 i;

  <bb 2> :
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  i = 0;
  goto <bb 6>; [INV]

  <bb 3> :
  Status = 0;
  _2 = (unsigned int) i;
  _3 = _2 * 2;
  _4 = ChansArray + _3;
  _5 = *_4;
  if (_5 <= 29)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = (unsigned int) i;
  _7 = _6 * 2;
  _8 = ChansArray + _7;
  _9 = *_8;
  u32CoreId.42_10 = u32CoreId;
  _11 = (unsigned int) i;
  _12 = _11 * 2;
  _13 = DataBufferPtr + _12;
  Status = Adc_Ipw_GetConvData (Unit, _9, u32CoreId.42_10, _13);

  <bb 5> :
  i.43_14 = i;
  i = i.43_14 + 1;

  <bb 6> :
  if (i < NumItems)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}


Adc_GetVersionInfo (struct Std_VersionInfoType * versioninfo)
{
  <bb 2> :
  versioninfo->vendorID = 43;
  versioninfo->moduleID = 123;
  versioninfo->sw_major_version = 1;
  versioninfo->sw_minor_version = 0;
  versioninfo->sw_patch_version = 0;
  return;

}


Adc_GetStreamLastPointer (Adc_GroupType Group, Adc_ValueGroupType * * PtrToSamplePtr)
{
  Adc_StreamNumSampleType ResultIndex;
  Adc_StreamNumSampleType NumberOfResults;
  const struct Adc_GroupConfigurationType * pGroupPtr;
  Adc_GroupType GroupIndex;
  volatile uint32 u32CoreId;
  Adc_StreamNumSampleType D.6973;

  <bb 2> :
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  GroupIndex = 0;
  NumberOfResults = 0;
  ResultIndex = 0;
  u32CoreId.36_2 = u32CoreId;
  _3 = Adc_pCfgPtr[u32CoreId.36_2];
  _4 = _3->pGroups;
  _5 = (unsigned int) GroupIndex;
  _6 = _5 * 60;
  pGroupPtr = _4 + _6;
  u32CoreId.37_7 = u32CoreId;
  _8 = Adc_ValidateStateNotIdle (11, Group, u32CoreId.37_7);
  if (_8 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 3> :
  *PtrToSamplePtr = 0B;
  _9 = (int) Group;
  _10 = Adc_aGroupStatus[_9].eConversion;
  if (_10 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 4> :
  _11 = (int) Group;
  _12 = Adc_aGroupStatus[_11].eConversion;
  if (_12 != 1)
    goto <bb 5>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 5> :
  u32CoreId.38_13 = u32CoreId;
  _14 = Adc_pCfgPtr[u32CoreId.38_13];
  _15 = _14->pGroupIdToIndexMap;
  _16 = (unsigned int) Group;
  _17 = _16 * 2;
  _18 = _15 + _17;
  GroupIndex = *_18;
  _19 = (int) Group;
  _20 = Adc_aGroupStatus[_19].ResultIndex;
  if (_20 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  u32CoreId.39_21 = u32CoreId;
  _22 = Adc_pCfgPtr[u32CoreId.39_21];
  _23 = _22->pGroups;
  _24 = (unsigned int) GroupIndex;
  _25 = _24 * 60;
  _26 = _23 + _25;
  _27 = _26->NumSamples;
  ResultIndex = _27 + 65535;
  u32CoreId.40_28 = u32CoreId;
  _29 = Adc_pCfgPtr[u32CoreId.40_28];
  _30 = _29->pGroups;
  _31 = (unsigned int) GroupIndex;
  _32 = _31 * 60;
  _33 = _30 + _32;
  NumberOfResults = _33->NumSamples;
  goto <bb 8>; [INV]

  <bb 7> :
  _34 = (int) Group;
  _35 = Adc_aGroupStatus[_34].ResultIndex;
  ResultIndex = _35 + 65535;
  _36 = (int) Group;
  NumberOfResults = Adc_aGroupStatus[_36].ResultIndex;

  <bb 8> :
  _37 = pGroupPtr->pResultsBufferPtr;
  _38 = (unsigned int) Group;
  _39 = _38 * 4;
  _40 = _37 + _39;
  _41 = *_40;
  _42 = (unsigned int) ResultIndex;
  _43 = _42 * 2;
  _44 = _41 + _43;
  *PtrToSamplePtr = _44;
  u32CoreId.41_45 = u32CoreId;
  Adc_UpdateStatusAfterGetStream (Group, u32CoreId.41_45);
  goto <bb 10>; [INV]

  <bb 9> :
  *PtrToSamplePtr = 0B;

  <bb 10> :
  D.6973 = NumberOfResults;

  <bb 11> :
<L10>:
  return D.6973;

}


Adc_GetGroupStatus (Adc_GroupType Group)
{
  Adc_StatusType eTempReturn;
  Adc_StatusType D.6961;

  <bb 2> :
  eTempReturn = 0;
  _1 = (int) Group;
  eTempReturn = Adc_aGroupStatus[_1].eConversion;
  D.6961 = eTempReturn;

  <bb 3> :
<L0>:
  return D.6961;

}


Adc_DisableGroupNotification (Adc_GroupType Group)
{
  <bb 2> :
  _1 = (int) Group;
  Adc_aGroupStatus[_1].eNotification = 0;
  return;

}


Adc_EnableGroupNotification (Adc_GroupType Group)
{
  <bb 2> :
  _1 = (int) Group;
  Adc_aGroupStatus[_1].eNotification = 1;
  return;

}


Adc_ReadGroup (Adc_GroupType Group, Adc_ValueGroupType * DataBufferPtr)
{
  boolean bFlag;
  Std_ReturnType GroupRet;
  volatile uint32 u32CoreId;
  Std_ReturnType D.6923;

  <bb 2> :
  GroupRet = 1;
  bFlag = 1;
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreId.30_2 = u32CoreId;
  _3 = Adc_ValidateStateNotIdle (4, Group, u32CoreId.30_2);
  if (_3 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  u32CoreId.31_4 = u32CoreId;
  GroupRet = Adc_Ipw_ReadGroup (Group, DataBufferPtr, &bFlag, u32CoreId.31_4);
  if (GroupRet == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 4> :
  bFlag.32_5 = bFlag;
  _6 = ~bFlag.32_5;
  if (_6 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  bFlag.33_7 = bFlag;
  u32CoreId.34_8 = u32CoreId;
  Adc_UpdateStatusReadGroup (Group, bFlag.33_7, u32CoreId.34_8);

  <bb 6> :
  D.6923 = GroupRet;
  bFlag = {CLOBBER};

  <bb 7> :
<L6>:
  return D.6923;

}


Adc_StopGroupConversion (Adc_GroupType Group)
{
  Adc_GroupType GroupIndex;
  volatile uint32 u32CoreId;
  Adc_HwUnitType LogicalHwUnitId;

  <bb 2> :
  LogicalHwUnitId = 0;
  GroupIndex = 0;
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreId.24_2 = u32CoreId;
  _3 = Adc_ValidateStateNotIdle (3, Group, u32CoreId.24_2);
  if (_3 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  u32CoreId.25_4 = u32CoreId;
  _5 = Adc_pCfgPtr[u32CoreId.25_4];
  _6 = _5->pGroupIdToIndexMap;
  _7 = (unsigned int) Group;
  _8 = _7 * 2;
  _9 = _6 + _8;
  GroupIndex = *_9;
  u32CoreId.26_10 = u32CoreId;
  _11 = Adc_pCfgPtr[u32CoreId.26_10];
  _12 = _11->pGroups;
  _13 = (unsigned int) GroupIndex;
  _14 = _13 * 60;
  _15 = _12 + _14;
  LogicalHwUnitId = _15->AdcLogicalUnitId;
  u32CoreId.27_16 = u32CoreId;
  Adc_UpdateStatusStopConversion (Group, LogicalHwUnitId, u32CoreId.27_16);

  <bb 4> :
  return;

}


Adc_StartGroupConversion (Adc_GroupType Group)
{
  Adc_HwUnitType LogicalHwUnitId;
  Adc_GroupType GroupIndex;
  volatile uint32 u32CoreId;

  <bb 2> :
  GroupIndex = 0;
  LogicalHwUnitId = 0;
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreId.20_2 = u32CoreId;
  _3 = Adc_pCfgPtr[u32CoreId.20_2];
  _4 = _3->pGroupIdToIndexMap;
  _5 = (unsigned int) Group;
  _6 = _5 * 2;
  _7 = _4 + _6;
  GroupIndex = *_7;
  u32CoreId.21_8 = u32CoreId;
  _9 = Adc_ValidateStateStartGroupConvNotBusy (Group, u32CoreId.21_8);
  if (_9 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  u32CoreId.22_10 = u32CoreId;
  _11 = Adc_pCfgPtr[u32CoreId.22_10];
  _12 = _11->pGroups;
  _13 = (unsigned int) GroupIndex;
  _14 = _13 * 60;
  _15 = _12 + _14;
  LogicalHwUnitId = _15->AdcLogicalUnitId;
  u32CoreId.23_16 = u32CoreId;
  Adc_UpdateStatusStartConversion (Group, LogicalHwUnitId, u32CoreId.23_16);

  <bb 4> :
  return;

}


Adc_DeInit ()
{
  Std_ReturnType ValidStatus;
  Std_ReturnType TempReturn;
  uint32 u32CoreIdTemp;
  Std_ReturnType ValidCoreId;
  Adc_HwUnitType LogicalHwUnitId;
  volatile uint32 u32CoreId;

  <bb 2> :
  LogicalHwUnitId = 0;
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreIdTemp = u32CoreId;
  u32CoreId.12_2 = u32CoreId;
  _3 = Adc_pCfgPtr[u32CoreId.12_2];
  ValidCoreId = Adc_CheckCurrentCoreId (_3, u32CoreIdTemp);
  if (ValidCoreId == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 3> :
  u32CoreId.13_4 = u32CoreId;
  ValidStatus = Adc_ValidateDeInitNotBusy (u32CoreId.13_4);
  if (ValidStatus == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 4> :
  u32CoreId.14_5 = u32CoreId;
  TempReturn = Adc_Ipw_DeInit (u32CoreId.14_5);
  if (TempReturn == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  Adc_ReportDetRuntimeError (1, 43);

  <bb 6> :
  LogicalHwUnitId = 0;
  goto <bb 10>; [INV]

  <bb 7> :
  u32CoreId.15_6 = u32CoreId;
  _7 = Adc_pCfgPtr[u32CoreId.15_6];
  _8 = _7->pAdcIpwConfig;
  _9 = (int) LogicalHwUnitId;
  _10 = _8->Mapping.au8Adc_HwUnit[_9];
  if (_10 == 1)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _11 = (int) LogicalHwUnitId;
  Adc_aUnitStatus[_11].u8Sc1Used = 0;

  <bb 9> :
  LogicalHwUnitId.16_12 = LogicalHwUnitId;
  LogicalHwUnitId = LogicalHwUnitId.16_12 + 1;

  <bb 10> :
  if (LogicalHwUnitId <= 1)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  u32CoreId.17_13 = u32CoreId;
  Adc_pCfgPtr[u32CoreId.17_13] = 0B;

  <bb 12> :
  return;

}


Adc_SetupResultBuffer (Adc_GroupType Group, Adc_ValueGroupType * const DataBufferPtr)
{
  const struct Adc_GroupConfigurationType * pGroupPtr;
  Std_ReturnType TempReturn;
  Adc_GroupType GroupIndex;
  volatile uint32 u32CoreId;
  Std_ReturnType D.6823;

  <bb 2> :
  TempReturn = 1;
  pGroupPtr = 0B;
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreId.10_2 = u32CoreId;
  _3 = Adc_pCfgPtr[u32CoreId.10_2];
  _4 = _3->pGroupIdToIndexMap;
  _5 = (unsigned int) Group;
  _6 = _5 * 2;
  _7 = _4 + _6;
  GroupIndex = *_7;
  _8 = Adc_ValidateSetupBufferNotBusy (Group);
  if (_8 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  u32CoreId.11_9 = u32CoreId;
  _10 = Adc_pCfgPtr[u32CoreId.11_9];
  _11 = _10->pGroups;
  _12 = (unsigned int) GroupIndex;
  _13 = _12 * 60;
  pGroupPtr = _11 + _13;
  _14 = pGroupPtr->pResultsBufferPtr;
  _15 = (unsigned int) Group;
  _16 = _15 * 4;
  _17 = _14 + _16;
  *_17 = DataBufferPtr;
  TempReturn = 0;

  <bb 4> :
  D.6823 = TempReturn;

  <bb 5> :
<L2>:
  return D.6823;

}


Adc_Init (const struct Adc_ConfigType * ConfigPtr)
{
  Std_ReturnType TimeOutStatus;
  Std_ReturnType ValidCoreId;
  uint32 u32CoreIdTemp;
  volatile uint32 u32CoreId;

  <bb 2> :
  _1 = Adc_GetCoreID ();
  u32CoreId = _1;
  u32CoreIdTemp = u32CoreId;
  u32CoreId.1_2 = u32CoreId;
  ValidCoreId = Adc_CheckCurrentCoreId (ConfigPtr, u32CoreId.1_2);
  if (ValidCoreId == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  u32CoreId.2_3 = u32CoreId;
  Adc_pCfgPtr[u32CoreId.2_3] = ConfigPtr;
  u32CoreId.3_4 = u32CoreId;
  Adc_InitUnitStatus (u32CoreId.3_4);
  u32CoreId.4_5 = u32CoreId;
  Adc_InitGroupsStatus (u32CoreId.4_5);
  u32CoreId.5_6 = u32CoreId;
  _7 = Adc_pCfgPtr[u32CoreId.5_6];
  _8 = _7->pAdcIpwConfig;
  TimeOutStatus = Adc_Ipw_Init (_8, u32CoreIdTemp);
  if (TimeOutStatus == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  Adc_ReportDetRuntimeError (0, 43);

  <bb 5> :
  return;

}


Adc_UpdateStatusAfterGetStream (Adc_GroupType Group, uint32 u32CoreId)
{
  Adc_GroupType GroupIndex;

  <bb 2> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  _6 = (int) Group;
  _7 = Adc_aGroupStatus[_6].eConversion;
  if (_7 == 2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _8 = (int) Group;
  Adc_aGroupStatus[_8].eConversion = 1;

  <bb 4> :
  _9 = (int) Group;
  _10 = Adc_aGroupStatus[_9].eConversion;
  if (_10 == 3)
    goto <bb 5>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 5> :
  _11 = Adc_pCfgPtr[u32CoreId];
  _12 = _11->pGroups;
  _13 = (unsigned int) GroupIndex;
  _14 = _13 * 60;
  _15 = _12 + _14;
  _16 = _15->eTriggerSource;
  if (_16 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 6> :
  _17 = Adc_pCfgPtr[u32CoreId];
  _18 = _17->pGroups;
  _19 = (unsigned int) GroupIndex;
  _20 = _19 * 60;
  _21 = _18 + _20;
  _22 = _21->eMode;
  if (_22 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _23 = Adc_pCfgPtr[u32CoreId];
  _24 = _23->pGroups;
  _25 = (unsigned int) GroupIndex;
  _26 = _25 * 60;
  _27 = _24 + _26;
  _28 = _27->eMode;
  if (_28 == 1)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  _29 = Adc_pCfgPtr[u32CoreId];
  _30 = _29->pGroups;
  _31 = (unsigned int) GroupIndex;
  _32 = _31 * 60;
  _33 = _30 + _32;
  _34 = _33->eAccessMode;
  if (_34 == 1)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _35 = Adc_pCfgPtr[u32CoreId];
  _36 = _35->pGroups;
  _37 = (unsigned int) GroupIndex;
  _38 = _37 * 60;
  _39 = _36 + _38;
  _40 = _39->eBufferMode;
  if (_40 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _41 = (int) Group;
  Adc_aGroupStatus[_41].eConversion = 0;
  goto <bb 12>; [INV]

  <bb 11> :
  _42 = (int) Group;
  Adc_aGroupStatus[_42].eConversion = 1;

  <bb 12> :
  return;

}


Adc_UpdateStatusReadGroupInt (const Adc_GroupType Group, uint32 u32CoreId)
{
  Adc_GroupType GroupIndex;

  <bb 2> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  _6 = (int) Group;
  _7 = Adc_aGroupStatus[_6].eConversion;
  if (_7 == 2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _8 = (int) Group;
  Adc_aGroupStatus[_8].eConversion = 1;
  goto <bb 13>; [INV]

  <bb 4> :
  _9 = (int) Group;
  _10 = Adc_aGroupStatus[_9].eConversion;
  if (_10 == 3)
    goto <bb 5>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 5> :
  _11 = Adc_pCfgPtr[u32CoreId];
  _12 = _11->pGroups;
  _13 = (unsigned int) GroupIndex;
  _14 = _13 * 60;
  _15 = _12 + _14;
  _16 = _15->eTriggerSource;
  if (_16 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 6> :
  _17 = Adc_pCfgPtr[u32CoreId];
  _18 = _17->pGroups;
  _19 = (unsigned int) GroupIndex;
  _20 = _19 * 60;
  _21 = _18 + _20;
  _22 = _21->eMode;
  if (_22 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _23 = Adc_pCfgPtr[u32CoreId];
  _24 = _23->pGroups;
  _25 = (unsigned int) GroupIndex;
  _26 = _25 * 60;
  _27 = _24 + _26;
  _28 = _27->eMode;
  if (_28 == 1)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  _29 = Adc_pCfgPtr[u32CoreId];
  _30 = _29->pGroups;
  _31 = (unsigned int) GroupIndex;
  _32 = _31 * 60;
  _33 = _30 + _32;
  _34 = _33->eAccessMode;
  if (_34 == 1)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _35 = Adc_pCfgPtr[u32CoreId];
  _36 = _35->pGroups;
  _37 = (unsigned int) GroupIndex;
  _38 = _37 * 60;
  _39 = _36 + _38;
  _40 = _39->eBufferMode;
  if (_40 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _41 = (int) Group;
  Adc_aGroupStatus[_41].eConversion = 0;
  goto <bb 12>; [INV]

  <bb 11> :
  _42 = (int) Group;
  Adc_aGroupStatus[_42].eConversion = 1;

  <bb 12> :

  <bb 13> :
  return;

}


Adc_UpdateSwQueueIndexNoInt (const Adc_GroupType Group, uint32 u32CoreId)
{
  Adc_QueueIndexType NumOfSwNormalQueue;
  Adc_QueueIndexType SwNormalQueueIndex;
  Adc_HwUnitType LogicalHwUnitId;
  Adc_GroupType GroupIndex;

  <bb 2> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  _6 = Adc_pCfgPtr[u32CoreId];
  _7 = _6->pGroups;
  _8 = (unsigned int) GroupIndex;
  _9 = _8 * 60;
  _10 = _7 + _9;
  LogicalHwUnitId = _10->AdcLogicalUnitId;
  _11 = (int) LogicalHwUnitId;
  _12 = Adc_aUnitStatus[_11].SwNormalQueueIndex;
  if (_12 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 3> :
  _13 = (int) LogicalHwUnitId;
  NumOfSwNormalQueue = Adc_aUnitStatus[_13].SwNormalQueueIndex;
  SwNormalQueueIndex = 0;
  goto <bb 7>; [INV]

  <bb 4> :
  _14 = (int) LogicalHwUnitId;
  _15 = (int) SwNormalQueueIndex;
  _16 = Adc_aUnitStatus[_14].SwNormalQueue[_15];
  if (Group == _16)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  Adc_RemoveFromQueue (LogicalHwUnitId, SwNormalQueueIndex);
  goto <bb 8>; [INV]

  <bb 6> :
  SwNormalQueueIndex.35_17 = SwNormalQueueIndex;
  SwNormalQueueIndex = SwNormalQueueIndex.35_17 + 1;

  <bb 7> :
  if (SwNormalQueueIndex < NumOfSwNormalQueue)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  if (SwNormalQueueIndex == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _18 = (int) LogicalHwUnitId;
  _19 = Adc_aUnitStatus[_18].SwNormalQueueIndex;
  if (_19 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  Adc_Ipw_StartNormalConversion (LogicalHwUnitId, u32CoreId);

  <bb 11> :
  return;

}


Adc_UpdateStatusReadGroupNoInt (const Adc_GroupType Group, const boolean bFlag, uint32 u32CoreId)
{
  Adc_GroupType GroupIndex;

  <bb 2> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  _6 = (int) Group;
  Adc_aGroupStatus[_6].eAlreadyConverted = 1;
  if (bFlag != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  _7 = Adc_pCfgPtr[u32CoreId];
  _8 = _7->pGroups;
  _9 = (unsigned int) GroupIndex;
  _10 = _9 * 60;
  _11 = _8 + _10;
  _12 = _11->eMode;
  if (_12 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _13 = (int) Group;
  Adc_aGroupStatus[_13].eConversion = 1;
  goto <bb 9>; [INV]

  <bb 5> :
  _14 = Adc_pCfgPtr[u32CoreId];
  _15 = _14->pGroups;
  _16 = (unsigned int) GroupIndex;
  _17 = _16 * 60;
  _18 = _15 + _17;
  _19 = _18->eTriggerSource;
  if (_19 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 6> :
  _20 = (int) Group;
  Adc_aGroupStatus[_20].eConversion = 0;
  Adc_UpdateSwQueueIndexNoInt (Group, u32CoreId);
  goto <bb 9>; [INV]

  <bb 7> :
  _21 = Adc_pCfgPtr[u32CoreId];
  _22 = _21->pGroups;
  _23 = (unsigned int) GroupIndex;
  _24 = _23 * 60;
  _25 = _22 + _24;
  _26 = _25->eMode;
  if (_26 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _27 = (int) Group;
  Adc_aGroupStatus[_27].eConversion = 1;

  <bb 9> :
  return;

}


Adc_UpdateStatusReadGroup (const Adc_GroupType Group, const boolean bFlag, uint32 u32CoreId)
{
  Adc_GroupType GroupIndex;

  <bb 2> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  _6 = Adc_pCfgPtr[u32CoreId];
  _7 = _6->pGroups;
  _8 = (unsigned int) GroupIndex;
  _9 = _8 * 60;
  _10 = _7 + _9;
  _11 = _10->u8AdcWithoutInterrupt;
  if (_11 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  Adc_UpdateStatusReadGroupNoInt (Group, bFlag, u32CoreId);
  goto <bb 5>; [INV]

  <bb 4> :
  Adc_UpdateStatusReadGroupInt (Group, u32CoreId);

  <bb 5> :
  return;

}


Adc_UpdateStatusStopConversion (Adc_GroupType Group, Adc_HwUnitType Unit, uint32 u32CoreId)
{
  Adc_StatusType eConversion;
  Adc_StreamBufferModeType eBufferMode;
  Adc_GroupAccessModeType eAccessMode;
  Adc_GroupConvModeType eMode;
  Std_ReturnType TimeOutStatus;
  Adc_QueueIndexType RemovedPos;
  Adc_GroupType GroupIndex;

  <bb 2> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  RemovedPos = 0;
  TimeOutStatus = 0;
  _6 = (int) Group;
  Adc_aGroupStatus[_6].bLimitCheckFailed = 0;
  _7 = Adc_pCfgPtr[u32CoreId];
  _8 = _7->pGroups;
  _9 = (unsigned int) GroupIndex;
  _10 = _9 * 60;
  _11 = _8 + _10;
  eMode = _11->eMode;
  _12 = Adc_pCfgPtr[u32CoreId];
  _13 = _12->pGroups;
  _14 = (unsigned int) GroupIndex;
  _15 = _14 * 60;
  _16 = _13 + _15;
  eAccessMode = _16->eAccessMode;
  _17 = Adc_pCfgPtr[u32CoreId];
  _18 = _17->pGroups;
  _19 = (unsigned int) GroupIndex;
  _20 = _19 * 60;
  _21 = _18 + _20;
  eBufferMode = _21->eBufferMode;
  _22 = (int) Group;
  eConversion = Adc_aGroupStatus[_22].eConversion;
  _23 = (int) Group;
  Adc_aGroupStatus[_23].ResultIndex = 0;
  _24 = (int) Group;
  Adc_aGroupStatus[_24].eNotification = 0;
  _25 = (int) Group;
  Adc_aRuntimeGroupChannel[_25].u32Mask = 4294967295;
  if (eMode == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (eAccessMode == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  if (eBufferMode == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  if (eConversion == 3)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _26 = (int) Group;
  Adc_aGroupStatus[_26].eConversion = 0;
  goto <bb 12>; [INV]

  <bb 7> :
  TimeOutStatus = Adc_StopSwGroupConversion (&RemovedPos, Group, Unit, u32CoreId);
  _27 = (int) Group;
  Adc_aGroupStatus[_27].eConversion = 0;
  RemovedPos.28_28 = RemovedPos;
  if (RemovedPos.28_28 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  _29 = (int) Unit;
  _30 = Adc_aUnitStatus[_29].SwNormalQueueIndex;
  if (_30 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  Adc_Ipw_StartNormalConversion (Unit, u32CoreId);

  <bb 10> :
  if (TimeOutStatus == 1)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  Adc_ReportDetRuntimeError (3, 43);

  <bb 12> :
  RemovedPos = {CLOBBER};
  return;

}


Adc_StopSwGroupConversion (Adc_QueueIndexType * RemovedPos, Adc_GroupType Group, Adc_HwUnitType Unit, uint32 u32CoreId)
{
  Adc_QueueIndexType NumOfSwNormalQueue;
  Adc_QueueIndexType SwNormalQueueIndex;
  Std_ReturnType TimeOutStatus;
  Std_ReturnType D.6916;

  <bb 2> :
  TimeOutStatus = 0;
  _1 = (int) Unit;
  _2 = Adc_aUnitStatus[_1].SwNormalQueueIndex;
  *RemovedPos = _2;
  _3 = (int) Unit;
  NumOfSwNormalQueue = Adc_aUnitStatus[_3].SwNormalQueueIndex;
  SwNormalQueueIndex = 0;
  goto <bb 8>; [INV]

  <bb 3> :
  _4 = (int) Unit;
  _5 = (int) SwNormalQueueIndex;
  _6 = Adc_aUnitStatus[_4].SwNormalQueue[_5];
  if (Group == _6)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  *RemovedPos = SwNormalQueueIndex;
  if (SwNormalQueueIndex == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  TimeOutStatus = Adc_Ipw_StopCurrentConversion (Unit, Group, u32CoreId);

  <bb 6> :
  Adc_RemoveFromQueue (Unit, SwNormalQueueIndex);

  <bb 7> :
  SwNormalQueueIndex.29_7 = SwNormalQueueIndex;
  SwNormalQueueIndex = SwNormalQueueIndex.29_7 + 1;

  <bb 8> :
  if (SwNormalQueueIndex < NumOfSwNormalQueue)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.6916 = TimeOutStatus;

  <bb 10> :
<L7>:
  return D.6916;

}


Adc_UpdateStatusStartConversion (const Adc_GroupType Group, const Adc_HwUnitType Unit, uint32 u32CoreId)
{
  Std_ReturnType TimeOutStatus;
  Adc_QueueIndexType SwNormalQueueIndex;

  <bb 2> :
  TimeOutStatus = 0;
  _1 = (int) Group;
  Adc_aGroupStatus[_1].eConversion = 1;
  _2 = (int) Group;
  Adc_aGroupStatus[_2].ResultIndex = 0;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01 ();
  _3 = (int) Unit;
  SwNormalQueueIndex = Adc_aUnitStatus[_3].SwNormalQueueIndex;
  _4 = (int) Unit;
  _5 = Adc_aUnitStatus[_4].SwNormalQueue[0];
  if (Group == _5)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (SwNormalQueueIndex == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  _6 = (int) Unit;
  _7 = Adc_aUnitStatus[_6].SwNormalQueueIndex;
  if (_7 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _8 = (int) Unit;
  Adc_aUnitStatus[_8].SwNormalQueue[0] = Group;
  _9 = (int) Unit;
  _10 = Adc_aUnitStatus[_9].SwNormalQueueIndex;
  _11 = _10;
  _12 = _11 + 1;
  Adc_aUnitStatus[_9].SwNormalQueueIndex = _12;

  <bb 6> :
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01 ();
  Adc_Ipw_StartNormalConversion (Unit, u32CoreId);
  goto <bb 8>; [INV]

  <bb 7> :
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01 ();

  <bb 8> :
  return;

}


Adc_RemoveFromQueue (const Adc_HwUnitType Unit, const Adc_QueueIndexType CurQueueIndex)
{
  Adc_QueueIndexType CurrentIndex;
  Adc_QueueIndexType PositionIndex;

  <bb 2> :
  PositionIndex = 0;
  CurrentIndex = 0;
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00 ();
  _1 = (int) Unit;
  CurrentIndex = Adc_aUnitStatus[_1].SwNormalQueueIndex;
  if (CurrentIndex <= 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _2 = (int) Unit;
  Adc_aUnitStatus[_2].SwNormalQueueIndex = 0;
  goto <bb 8>; [INV]

  <bb 4> :
  PositionIndex = CurQueueIndex + 1;
  goto <bb 6>; [INV]

  <bb 5> :
  _3 = (int) Unit;
  _4 = (int) PositionIndex;
  _5 = (int) Unit;
  _6 = (unsigned int) PositionIndex;
  _7 = _6 + 4294967295;
  _8 = Adc_aUnitStatus[_3].SwNormalQueue[_4];
  Adc_aUnitStatus[_5].SwNormalQueue[_7] = _8;
  PositionIndex.0_9 = PositionIndex;
  PositionIndex = PositionIndex.0_9 + 1;

  <bb 6> :
  if (PositionIndex < CurrentIndex)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _10 = (int) Unit;
  _11 = Adc_aUnitStatus[_10].SwNormalQueueIndex;
  _12 = _11;
  _13 = _12 + 65535;
  Adc_aUnitStatus[_10].SwNormalQueueIndex = _13;

  <bb 8> :
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00 ();
  return;

}


Adc_CheckCurrentCoreId (const struct Adc_ConfigType * pCfgPtr, uint32 u32CoreId)
{
  Std_ReturnType ValidCoreId;
  uint8 Index;
  Std_ReturnType D.6817;

  <bb 2> :
  Index = 0;
  ValidCoreId = 1;
  _1 = pCfgPtr->u32CoreId;
  if (u32CoreId == _1)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  Index = 0;
  goto <bb 7>; [INV]

  <bb 4> :
  _2 = pCfgPtr->pAssignmentPartition;
  _3 = (sizetype) Index;
  _4 = _2 + _3;
  _5 = *_4;
  _6 = (long unsigned int) _5;
  if (u32CoreId == _6)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  ValidCoreId = 0;
  goto <bb 8>; [INV]

  <bb 6> :
  Index.6_7 = Index;
  Index = Index.6_7 + 1;

  <bb 7> :
  _8 = pCfgPtr->AssignedPartitionCount;
  if (Index < _8)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  D.6817 = ValidCoreId;

  <bb 9> :
<L7>:
  return D.6817;

}


Adc_InitUnitStatus (uint32 u32CoreId)
{
  Adc_QueueIndexType QueueIdx;
  Adc_HwUnitType LogicalHwUnitId;

  <bb 2> :
  LogicalHwUnitId = 0;
  QueueIdx = 0;
  LogicalHwUnitId = 0;
  goto <bb 9>; [INV]

  <bb 3> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pAdcIpwConfig;
  _3 = (int) LogicalHwUnitId;
  _4 = _2->Mapping.au8Adc_HwUnit[_3];
  if (_4 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  _5 = (int) LogicalHwUnitId;
  Adc_aUnitStatus[_5].SwNormalQueueIndex = 0;
  QueueIdx = 0;
  goto <bb 6>; [INV]

  <bb 5> :
  _6 = (int) LogicalHwUnitId;
  _7 = (int) QueueIdx;
  Adc_aUnitStatus[_6].SwNormalQueue[_7] = 0;
  QueueIdx.7_8 = QueueIdx;
  QueueIdx = QueueIdx.7_8 + 1;

  <bb 6> :
  if (QueueIdx == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _9 = (int) LogicalHwUnitId;
  Adc_aUnitStatus[_9].u8Sc1Used = 0;

  <bb 8> :
  LogicalHwUnitId.8_10 = LogicalHwUnitId;
  LogicalHwUnitId = LogicalHwUnitId.8_10 + 1;

  <bb 9> :
  if (LogicalHwUnitId <= 1)
    goto <bb 3>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  return;

}


Adc_InitGroupsStatus (uint32 u32CoreId)
{
  Adc_GroupType GroupId;
  Adc_GroupType u16GroupCnt;

  <bb 2> :
  u16GroupCnt = 0;
  GroupId = 0;
  u16GroupCnt = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroups;
  _3 = (unsigned int) u16GroupCnt;
  _4 = _3 * 60;
  _5 = _2 + _4;
  GroupId = _5->GroupId;
  _6 = (int) GroupId;
  Adc_aGroupStatus[_6].eConversion = 0;
  _7 = (int) GroupId;
  Adc_aGroupStatus[_7].eAlreadyConverted = 0;
  _8 = (int) GroupId;
  Adc_aGroupStatus[_8].ResultIndex = 0;
  _9 = (int) GroupId;
  Adc_aGroupStatus[_9].CurrentChannel = 0;
  _10 = (int) GroupId;
  Adc_aGroupStatus[_10].bLimitCheckFailed = 0;
  _11 = (int) GroupId;
  Adc_aGroupStatus[_11].eNotification = 0;
  _12 = Adc_pCfgPtr[u32CoreId];
  _13 = _12->pGroups;
  _14 = (unsigned int) u16GroupCnt;
  _15 = _14 * 60;
  _16 = _13 + _15;
  _17 = (int) GroupId;
  _18 = _16->pAssignment;
  Adc_aRuntimeGroupChannel[_17].pChannel = _18;
  _19 = Adc_pCfgPtr[u32CoreId];
  _20 = _19->pGroups;
  _21 = (unsigned int) u16GroupCnt;
  _22 = _21 * 60;
  _23 = _20 + _22;
  _24 = (int) GroupId;
  _25 = _23->AssignedChannelCount;
  Adc_aRuntimeGroupChannel[_24].ChannelCount = _25;
  _26 = (int) GroupId;
  Adc_aRuntimeGroupChannel[_26].bRuntimeUpdated = 0;
  _27 = (int) GroupId;
  Adc_aRuntimeGroupChannel[_27].bAdcRuntimeGroupLimitcheck = 0;
  _28 = Adc_pCfgPtr[u32CoreId];
  _29 = _28->pGroups;
  _30 = (unsigned int) u16GroupCnt;
  _31 = _30 * 60;
  _32 = _29 + _31;
  _33 = _32->pAdcIpwGroupConfig;
  _34 = (int) GroupId;
  _35 = _33->pDelay;
  Adc_aRuntimeGroupChannel[_34].pu16Delays = _35;
  _36 = (int) GroupId;
  Adc_aRuntimeGroupChannel[_36].u32Mask = 4294967295;
  u16GroupCnt.9_37 = u16GroupCnt;
  u16GroupCnt = u16GroupCnt.9_37 + 1;

  <bb 4> :
  _38 = Adc_pCfgPtr[u32CoreId];
  _39 = _38->GroupCount;
  if (u16GroupCnt < _39)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  return;

}


Adc_ValidateStateNotIdle (uint8 u8ServiceId, Adc_GroupType Group, uint32 u32CoreId)
{
  Std_ReturnType ValidState;
  Std_ReturnType D.6898;

  <bb 2> :
  ValidState = 0;
  _1 = (int) u8ServiceId;
  switch (_1) <default: <L12> [INV], case 3: <L5> [INV], case 4: <L0> [INV], case 11: <L9> [INV]>

  <bb 3> :
<L0>:
  _2 = (int) Group;
  _3 = Adc_aGroupStatus[_2].eConversion;
  if (_3 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _4 = (int) Group;
  _5 = Adc_aGroupStatus[_4].eAlreadyConverted;
  if (_5 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  Adc_ReportDetRuntimeError (u8ServiceId, 12);
  ValidState = 1;

  <bb 6> :
  goto <bb 14>; [INV]

  <bb 7> :
<L5>:
  _6 = (int) Group;
  _7 = Adc_aGroupStatus[_6].eConversion;
  if (_7 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  Adc_ReportDetRuntimeError (u8ServiceId, 12);
  ValidState = 1;

  <bb 9> :
  goto <bb 14>; [INV]

  <bb 10> :
<L9>:
  _8 = (int) Group;
  _9 = Adc_aGroupStatus[_8].eConversion;
  if (_9 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  Adc_ReportDetRuntimeError (u8ServiceId, 12);
  ValidState = 1;

  <bb 12> :
  goto <bb 14>; [INV]

  <bb 13> :
<L12>:

  <bb 14> :
  D.6898 = ValidState;

  <bb 15> :
<L14>:
  return D.6898;

}


Adc_ValidateStateStartGroupConvNotBusy (Adc_GroupType Group, uint32 u32CoreId)
{
  boolean bImplicitly;
  Std_ReturnType ValidState;
  Adc_GroupType GroupIndex;
  Std_ReturnType D.6868;

  <bb 2> :
  ValidState = 0;
  bImplicitly = 0;
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroupIdToIndexMap;
  _3 = (unsigned int) Group;
  _4 = _3 * 2;
  _5 = _2 + _4;
  GroupIndex = *_5;
  _6 = Adc_pCfgPtr[u32CoreId];
  _7 = _6->pGroups;
  _8 = (unsigned int) GroupIndex;
  _9 = _8 * 60;
  _10 = _7 + _9;
  _11 = _10->eMode;
  if (_11 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  _12 = Adc_pCfgPtr[u32CoreId];
  _13 = _12->pGroups;
  _14 = (unsigned int) GroupIndex;
  _15 = _14 * 60;
  _16 = _13 + _15;
  _17 = _16->eMode;
  if (_17 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  _18 = Adc_pCfgPtr[u32CoreId];
  _19 = _18->pGroups;
  _20 = (unsigned int) GroupIndex;
  _21 = _20 * 60;
  _22 = _19 + _21;
  _23 = _22->eAccessMode;
  if (_23 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _24 = Adc_pCfgPtr[u32CoreId];
  _25 = _24->pGroups;
  _26 = (unsigned int) GroupIndex;
  _27 = _26 * 60;
  _28 = _25 + _27;
  _29 = _28->eBufferMode;
  if (_29 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  bImplicitly = 1;

  <bb 7> :
  if (ValidState == 1)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  Adc_ReportDetRuntimeError (2, 11);
  goto <bb 10>; [INV]

  <bb 9> :
  ValidState = Adc_ValidateNotBusyNoPrio (Group, bImplicitly, u32CoreId);

  <bb 10> :
  D.6868 = ValidState;

  <bb 11> :
<L8>:
  return D.6868;

}


Adc_ValidateSetupBufferNotBusy (Adc_GroupType Group)
{
  Std_ReturnType ValidState;
  Std_ReturnType D.6828;

  <bb 2> :
  ValidState = 1;
  _1 = (int) Group;
  _2 = Adc_aGroupStatus[_1].eConversion;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  Adc_ReportDetRuntimeError (12, 11);
  goto <bb 5>; [INV]

  <bb 4> :
  ValidState = 0;

  <bb 5> :
  D.6828 = ValidState;

  <bb 6> :
<L3>:
  return D.6828;

}


Adc_ValidateDeInitNotBusy (uint32 u32CoreId)
{
  Adc_HwUnitType LogicalHwUnitId;
  Std_ReturnType ValidState;
  Std_ReturnType ErrorFound;
  Std_ReturnType D.6846;

  <bb 2> :
  ErrorFound = 0;
  ValidState = 1;
  LogicalHwUnitId = 0;
  LogicalHwUnitId = 0;
  goto <bb 7>; [INV]

  <bb 3> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pAdcIpwConfig;
  _3 = (int) LogicalHwUnitId;
  _4 = _2->Mapping.au8Adc_HwUnit[_3];
  if (_4 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  ErrorFound = Adc_ValidateNotBusyNoQueue (LogicalHwUnitId, 1);
  if (ErrorFound == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  goto <bb 8>; [INV]

  <bb 6> :
  LogicalHwUnitId.18_5 = LogicalHwUnitId;
  LogicalHwUnitId = LogicalHwUnitId.18_5 + 1;

  <bb 7> :
  if (LogicalHwUnitId <= 1)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  if (ErrorFound == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _6 = Adc_ValidateCheckGroupNotConversion (1, u32CoreId);
  if (_6 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  ValidState = 0;

  <bb 11> :
  D.6846 = ValidState;

  <bb 12> :
<L11>:
  return D.6846;

}


Adc_ValidateCheckGroupNotConversion (uint8 u8ServiceId, uint32 u32CoreId)
{
  Std_ReturnType ErrorFound;
  Adc_GroupType GroupId;
  Adc_GroupType GroupIter;
  Adc_StatusType eConversion;
  Std_ReturnType D.6856;

  <bb 2> :
  ErrorFound = 0;
  GroupIter = 0;
  goto <bb 7>; [INV]

  <bb 3> :
  _1 = Adc_pCfgPtr[u32CoreId];
  _2 = _1->pGroups;
  _3 = (unsigned int) GroupIter;
  _4 = _3 * 60;
  _5 = _2 + _4;
  GroupId = _5->GroupId;
  _6 = (int) GroupId;
  eConversion = Adc_aGroupStatus[_6].eConversion;
  if (eConversion != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  if (eConversion != 3)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  Adc_ReportDetRuntimeError (u8ServiceId, 11);
  ErrorFound = 1;

  <bb 6> :
  GroupIter.19_7 = GroupIter;
  GroupIter = GroupIter.19_7 + 1;

  <bb 7> :
  _8 = Adc_pCfgPtr[u32CoreId];
  _9 = _8->GroupCount;
  if (GroupIter < _9)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  D.6856 = ErrorFound;

  <bb 9> :
<L7>:
  return D.6856;

}


Adc_ValidateNotBusyNoPrio (Adc_GroupType Group, boolean bImplicitly, uint32 u32CoreId)
{
  Adc_StatusType eConversion;
  Std_ReturnType ValidState;
  Std_ReturnType D.6879;

  <bb 2> :
  ValidState = 1;
  _1 = (int) Group;
  eConversion = Adc_aGroupStatus[_1].eConversion;
  _2 = ~bImplicitly;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  if (eConversion != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  Adc_ReportDetRuntimeError (2, 11);
  goto <bb 10>; [INV]

  <bb 5> :
  if (bImplicitly != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 6> :
  if (eConversion != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  if (eConversion != 3)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  Adc_ReportDetRuntimeError (2, 11);
  goto <bb 10>; [INV]

  <bb 9> :
  ValidState = 0;

  <bb 10> :
  D.6879 = ValidState;

  <bb 11> :
<L9>:
  return D.6879;

}


Adc_ValidateNotBusyNoQueue (Adc_HwUnitType Unit, uint8 u8ServiceId)
{
  Adc_GroupType NoGroupsInSwNormalQueue;
  Std_ReturnType ErrorFound;
  Std_ReturnType D.6850;

  <bb 2> :
  ErrorFound = 0;
  _1 = (int) Unit;
  NoGroupsInSwNormalQueue = Adc_aUnitStatus[_1].SwNormalQueueIndex;
  if (NoGroupsInSwNormalQueue != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  Adc_ReportDetRuntimeError (u8ServiceId, 11);
  ErrorFound = 1;

  <bb 4> :
  D.6850 = ErrorFound;

  <bb 5> :
<L2>:
  return D.6850;

}


Adc_ReportDetRuntimeError (uint8 u8ServiceId, uint8 u8ErrorId)
{
  <bb 2> :
  Det_ReportRuntimeError (123, 0, u8ServiceId, u8ErrorId);
  return;

}


